program RUNMESH

!>       MESH DRIVER
!>
!>       NOV 2015 - DGP. Moved incrementing the counters to
!>                  after routing has finished. This impacts when daily
!>                  and cumulative daily streamflow are written to file
!>                  and screen. The average daily streamflow was
!>                  calculated between 23:00-23:30 before the fix, tied
!>                  to an if statement about NCOUNT == 48, which
!>                  occurred shortly after NCOUNT = NCOUNT + 1 in the
!>                  same time-step. Average daily streamflow is
!>                  calculated between 23:30-24:00 after the fix. The
!>                  change causes results in MESH_output_streamflow.csv
!>                  and MESH_output_streamflow_cumulative.csv to differ
!>                  by the amount of flow calculated between
!>                  23:30-24:00. Metrics calculated based on streamflow
!>                  also change. The daily runoff generated by CLASS
!>                  remains unchanged.
!>                  Because metrics and streamflow results differ
!>                  between this and prior revisions, r909 might be
!>                  considered the start of MESH 1.4.
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.

    use sa_mesh_shared_variables

    use FLAGS

    use mpi_flags
    use mpi_shared_variables
    use mpi_module

    use sa_mesh_run_within_tile
    use sa_mesh_run_within_grid
    use sa_mesh_run_between_grid

    use MODEL_OUTPUT
    use model_output_variabletypes
    use climate_forcing
    use model_dates
    use SIMSTATS
    use model_files

    implicit none

    !* ierr: Diagnostic error/status return from various subroutines.
    integer :: ierr = 0

    integer istop, ierrcode, irecv, itag

    !> Local variables.
    !* NA: Temporary store for the number of grid cells.
    !* NTYPE: Temporary store for the number of GRUs.
    !* NML: Temporary store for the number of active land elements (NA, NTYPE).
    !* NSL: Temporary store for the number of soil layers.
    !* iun: Temporary store for the unit number of a file.
    integer NA, NTYPE, NML, NSL, iun, ik, jk, ignd
    real FRAC

    !> INTEGER CONSTANTS.
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
!-    integer, parameter :: M_C = 5

!todo clean up commets and arrange variables a bit better

    !> FOR ROUTING
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
    !* WF_R1: MANNING'S N FOR RIVER CHANNEL
    !* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
!-    real WF_R1(M_C), WF_R2(M_C)

!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
    character(10) wf_landclassname(10)
    integer(kind = 4) wfo_yy, wfo_mm, wfo_dd, wfo_hh, wfo_mi, wfo_ss, &
        wfo_ms, nj, ensim_month, ensim_day
    integer(kind = 4) WFO_SEQ, ENSIM_IOS
    integer(kind = 4) CURREC
!> == ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

    !> For reading in the last information in mesh_paramters_hydrology.ini
    character(30) NMTESTFORMAT

    !> CONSTANTS (PARAMETER DEFINITIONS):
    !* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
    !* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
    !* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
    !* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
    !* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
    !* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

    !* VERSION: MESH_DRIVER VERSION
    !* RELEASE: PROGRAM RELEASE VERSIONS
    !* VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
    character(24) :: VERSION = '1037'
    character(8) RELEASE
!-    logical VER_OK

    !* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
    !* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
    integer i, j, k, l, m, u
!-    integer INDEPPAR, DEPPAR

    integer FRAME_NO_NEW

    !> MAM - logical variables to control simulation runs:
    character(100) cstate
    logical :: ENDDATE = .false., ENDDATA = .false.
    integer :: RUNSTATE = 0

    !>  For cacluating the subbasin grids
!+    integer SUBBASINCOUNT
!+    integer, dimension(:), allocatable :: SUBBASIN

    type(ShedGridParams) :: shd
    type(fl_ids) :: fls

    !* printoutwb: Print components of the water balance to the
    !*             console if enabled.
    logical printoutwb

    !* printoutstfl: Print members of the simulation hydrograph to the
    !*               console if enabled.
    logical printoutstfl, printoutqhyd

    !>THESE ARE THTE TYPES DEFINED IN MODEL_OUTPUT.F95 NEED TO WRITE OUTPUT FIELD ACCUMULATED
    !> OR AVERAGE FOR THE WATER BALANCE AND SOME OTHER STATES VARIABLES
!todo: clean-up.
    type(OUT_FLDS) :: VR
    type(dates_model) :: ts
    type(INFO_OUT) :: ifo
    type(CLIM_INFO) :: cm
    type(met_data) :: md_grd
    type(water_balance) :: wb_grd, wb_acc
    type(energy_balance) :: eb_grd, eb_acc
    type(soil_statevars) :: spv_grd, spv_acc
    type(streamflow_hydrograph) :: stfl
    type(reservoir_release) :: rrls

    !> Basin totals for the run.
    real TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, STG_INI, STG_FIN, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB

    !> End of run states for prognostic variables.
    real, dimension(:, :), allocatable :: tcan, rcan, sncan, gro, zpnd, tpnd, sno, tsno, albs, rhos
    real, dimension(:, :, :), allocatable :: tbar, thlq, thic
    integer, dimension(:), allocatable :: kc
    character cfmt*3, cfmtt*1000

    logical R2COUTPUT
    integer, parameter :: R2CFILEUNITSTART = 500
    integer NR2C, DELTR2C, NR2CFILES, NR2CSTATES, NR2C_R, DELTR2C_R, NR2C_S, DELTR2C_S
    integer, allocatable, dimension(:) :: GRD, GAT, GRDGAT, GRD_R, GAT_R, GRDGAT_R, GRD_S, GAT_S, GRDGAT_S
    character(50), allocatable, dimension(:, :) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

    !> To use with variable format expressions in writing some output files
    character(500) fl_listMesh

    real startprog, endprog
    integer narg
!+    real alpharain
!+    character(50) alphCh

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!todo: this should be input file dependent,
!because different files will work with different releases
!so, make them local variables inside each read subroutine.
    RELEASE = '1.4'

    call cpu_time(startprog)

    !> Initialize MPI.
    call mpi_init(ierr)
    if (ierr /= mpi_success) then
        print *, 'Failed to initialize MPI.'
        call mpi_abort(mpi_comm_world, ierrcode, ierr)
        print *, 'ierrcode ', ierrcode, 'ierr ', ierr
    end if

    !> Grab number of total processes and current process ID.
    call mpi_comm_size(mpi_comm_world, inp, ierr)
    call mpi_comm_rank(mpi_comm_world, ipid, ierr)

    !> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ro%VERBOSEMODE = 0

!TODO: UPDATE THIS (RELEASE(*)) WITH VERSION CHANGE
    if (ro%VERBOSEMODE > 0) print 951, trim(RELEASE), trim(VERSION)

951 format(1x, 'MESH ', a, ' ---  (', a, ')', /)

    !> Check if any command line arguments are found.
    narg = command_argument_count()
    !print *, narg
    if (narg > 0) then

        !> File handled for variable in/out names
        !> At the moment only class, hydro parameters and some outputs
        VARIABLEFILESFLAG = 1
        if (narg >= 1) then
            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!        else if (narg == 2) then
!            call get_command_argument(1, fl_listMesh)
!            print *, fl_listMesh
!todo: re-instate alpha
!            call get_command_argument(2, alphCh)
!            call value(alphCh, alpharain, ierr)
!            cm%dat(8)%alpha = alpha
!            print *, cm%dat(8)%alpha
        end if
        call Init_fls(fls, trim(adjustl(fl_listMesh)))
    else
!todo: Call this anyway, make loading values from file an alternate subroutine of module_files
        call Init_fls(fls)
    end if !(narg > 0) then

!-    call counter_init()

    call READ_INITIAL_INPUTS(shd, &
                             ts, cm, &
                             fls)

    !> Assign shed values to local variables.
    NA = shd%NA
    NTYPE = shd%lc%NTYPE
    NSL = shd%lc%IGND

    !> Initialize output fields.
    call init_water_balance(wb_grd, shd)
    call init_energy_balance(eb_grd, shd)
    call init_soil_statevars(spv_grd, shd)

    !> Calculate the grid and basin fractional areas.
    wb_grd%grid_area = 0.0
    wb_grd%basin_area = 0.0
    do i = 1, NA
        do m = 1, NTYPE
            wb_grd%grid_area(i) = wb_grd%grid_area(i) + shd%lc%ACLASS(i, m)*shd%FRAC(i)
        end do
        wb_grd%basin_area = wb_grd%basin_area + wb_grd%grid_area(i)
    end do

    if (ipid == 0) then

        !> Hourly output.
        call init_met_data(md_grd, shd)

        !> Daily average grid values.
        call init_energy_balance(eb_acc, shd)
        call init_soil_statevars(spv_acc, shd)
        call init_water_balance(wb_acc, shd)

        !> Basin totals for the run.
        TOTAL_PRE = 0.0
        TOTAL_EVAP = 0.0
        TOTAL_ROF = 0.0
        TOTAL_ROFO = 0.0
        TOTAL_ROFS = 0.0
        TOTAL_ROFB = 0.0

    end if !(ipid == 0) then

    call run_within_tile_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
    call run_within_grid_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

    NML = shd%lc%NML

    !> MAM - Check for parameter values - all parameters should lie within the
    !> specified ranges in the "minmax_parameters.txt" file.
    call check_parameters(shd)

    !> ALLOCATE ALL VARIABLES

1114 format(/1x, 'Error allocating ', a, ' variables.', &
            /1x, 'Check that these bounds are within an acceptable range.', /)
1118 format(3x, a, ': ', i6)

    !>  For cacluating the subbasin grids
!+    allocate(SUBBASIN(NML), stat = ierr)
!+    if (ierr /= 0) then
!+        print 1114, 'subbasin grid'
!+        print 1118, 'Grid squares', NA
!+        print 1118, 'GRUs', NTYPE
!+        print 1118, 'Total tile elements', NML
!+        stop
!+    end if

    if (ipid == 0) call run_between_grid_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

!> **********************************************************************
!>  Start of section to only run on squares that make up the watersheds
!>  that are listed in the streamflow file (subbasin)
!> **********************************************************************

!+    if (SUBBASINFLAG > 0) then
!+        do i = 1, NA
!+            SUBBASIN(i) = 0
!+        end do

          !> Set values at guages to 1
!+        do i = 1, WF_NO
!+            SUBBASIN(WF_S(i)) = 1
!+        end do

          !> Set values of subbasin to 1 for all upstream grids
!+        SUBBASINCOUNT = 1
!+        do while (SUBBASINCOUNT > 0)
!+            SUBBASINCOUNT = 0
!+            do i = 1, NA - 1
!+                if (SUBBASIN(shd%NEXT(i)) == 1 .and. SUBBASIN(i) == 0) then
!+                    SUBBASIN(i) = 1
!+                    SUBBASINCOUNT = SUBBASINCOUNT + 1
!+                end if
!+            end do
!+        end do !while (SUBBASINCOUNT > 0)

          !> Set values of frac to 0 for all grids non-upstream grids
!+        SUBBASINCOUNT = 0
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+                shd%FRAC(i) = 0.0
!+            else
!+                SUBBASINCOUNT = SUBBASINCOUNT + 1
!+            end if
!+        end do

          !> MAM - Write grid number, grid fractional area and percentage of GRUs in each grid
!+        open(10, file = 'subbasin_info.txt')
!+        write(10, '(a7, 3x, a18, 3x, a58)') &
!+            'GRID NO', 'GRID AREA FRACTION', 'GRU FRACTIONS, GRU 1, GRU 2, GRU 3,... IN INCREASING ORDER'
!+        do i = 1, NA
!+            if (SUBBASIN(i) == 0) then
!+            else
!+                write(10, '(i5, 3x, f10.3, 8x, 50(f10.3, 3x))') i, shd%FRAC(i), (shd%lc%ACLASS(i, m), m = 1, NMTEST)
!+            end if
!+        end do
!+        close(10)

!+    end if !(SUBBASINFLAG > 0) then

!> **********************************************************************
!>  End of subbasin section
!> **********************************************************************

    ENDDATA = climate_module_init(fls, shd, il1, il2, cm)
    if (ENDDATA) then
        RUNSTATE = 1
        goto 997
    end if

    !> Initialize output fields.
    if (ipid == 0) then
        if (OUTFIELDSFLAG == 1) call init_out(shd, ts, ifo, vr)
    end if !(ipid == 0) then

    FRAME_NO_NEW = 1

    !> Determine what output will print to the console.
    printoutwb = (allocated(wb_acc%pre) .and. allocated(wb_acc%evap) .and. allocated(wb_acc%rof))
    printoutstfl = allocated(stfl%qsyn)
    printoutqhyd = (allocated(stfl%qhyd) .and. allocated(stfl%qsyn))

    if (ipid == 0) then

    !> ******************************************************
    !> echo print information to MESH_output_echo_print.txt
    !> ******************************************************

        if (MODELINFOOUTFLAG > 0) then
            write(58, "('Number of Soil Layers (IGND) = ', i5)") NSL
            write(58, *)
            write(58, "('MESH_input_run_options.ini')")
            write(58, *)
            write(58, "('Configuration flags - specified by user or default values')")

!todo: this list should be updated (dgp: 2015-01-09)
            write(58, *) 'BASINSHORTWAVEFLAG   = ', cm%dat(ck%FB)%ffmt
            write(58, *) 'BASINLONGWAVEFLAG    = ', cm%dat(ck%FI)%ffmt
            write(58, *) 'BASINRAINFLAG        = ', cm%dat(ck%RT)%ffmt
            write(58, *) 'BASINTEMPERATUREFLAG = ', cm%dat(ck%TT)%ffmt
            write(58, *) 'BASINWINDFLAG        = ', cm%dat(ck%UV)%ffmt
            write(58, *) 'BASINPRESFLAG        = ', cm%dat(ck%P0)%ffmt
            write(58, *) 'BASINHUMIDITYFLAG    = ', cm%dat(ck%HU)%ffmt
!-            write(58, *) 'HOURLYFLAG           = ', HOURLYFLAG
            write(58, *) 'RESUMEFLAG           = ', RESUMEFLAG
            write(58, *) 'SAVERESUMEFLAG       = ', SAVERESUMEFLAG
            write(58, *) 'SHDFILEFLAG          = ', SHDFILEFLAG
            write(58, *) 'SOILINIFLAG          = ', SOILINIFLAG
            write(58, *) 'PREEMPTIONFLAG       = ', mtsflg%PREEMPTIONFLAG
!-            write(58, *) 'INTERPOLATIONFLAG    = ', INTERPOLATIONFLAG
            write(58, *) 'SUBBASINFLAG         = ', SUBBASINFLAG
            write(58, *) 'R2COUTPUTFLAG        = ', R2COUTPUTFLAG
            write(58, *) 'OBJFNFLAG            = ', OBJFNFLAG
            write(58, *) 'AUTOCALIBRATIONFLAG  = ', mtsflg%AUTOCALIBRATIONFLAG
            write(58, *) 'WINDOWSIZEFLAG       = ', WINDOWSIZEFLAG
            write(58, *) 'WINDOWSPACINGFLAG    = ', WINDOWSPACINGFLAG
            write(58, *) 'FROZENSOILINFILFLAG  = ', FROZENSOILINFILFLAG
            write(58, *) 'LOCATIONFLAG         = ', LOCATIONFLAG

!todo: restore this.
!+            write(58, "('WF_NUM_POINTS: ', i5)") WF_NUM_POINTS
!+            write(58, "('Out directory:', 5a10)") (op%DIR_OUT(i), i = 1, WF_NUM_POINTS)
!+            write(58, "('Grid number:  ', 5i10)") (op%N_OUT(i), i = 1, WF_NUM_POINTS)
!+            write(58, "('Land class:   ', 5i10)") (op%II_OUT(i), i = 1, WF_NUM_POINTS)
!            write(58, *)
!            write(58, "('MESH_parameters_hydrology.ini')")
!            write(58, *)
!todo: fix this.
!-            write(58, "('Option flags:')")
!-            if (OPTFLAGS > 0) then
!-                do i = 1, OPTFLAGS
!-                    write(58, '(a11, i2, a19)') 'PARAMETER ', i, ' NOT CURRENTLY USED'
!-                end do
!-            end if
!            write(58, "('River roughnesses:')")
!todo: change this to use NRVR.
!            write(58, '(5f6.3)') (WF_R2(i), i = 1, 5)
!            write(58, "('Land class independent hydrologic parameters:')")
!            if (FROZENSOILINFILFLAG == 1) then
!                write(58, *) 'SOIL_POR_MAX = ', SOIL_POR_MAX
!                write(58, *) 'SOIL_DEPTH   = ', SOIL_DEPTH
!                write(58, *) 'S0           = ', S0
!                write(58, *) 'T_ICE_LENS   = ', T_ICE_LENS
!                do i = 5, INDEPPAR
!                    j = i - 4
!                    write(58, '(a38, i2, a3, f6.2)') 'OPPORTUNITY TIME FOR SIMULATION YEAR ', j, ' = ', t0_ACC(j)
!                end do
!            else
!                do i = 1, INDEPPAR
!                    write(58, '(a36, i2, a19)') 'FROZEN SOIL INFILTRATION PARAMETER ', i, ' READ BUT NOT USED'
!                end do
!            end if !(FROZENSOILINFILFLAG == 1) then
!            write(58, "('Land class dependent hydrologic parameters:')")
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZSNLROW'", NTYPE
!            write(58, NMTESTFORMAT) (hp%ZSNLROW(1, m), m = 1, NTYPE)
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLSROW'", NTYPE
!            write(58, NMTESTFORMAT) (hp%ZPLSROW(1, m), m = 1, NTYPE)
!            write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('ZPLGROW'", NTYPE
!            write(58, NMTESTFORMAT) (hp%ZPLGROW(1, m), m = 1, NTYPE)
!            if (DEPPAR >= 4) then
!                write(NMTESTFORMAT, "(a10, i3, 'f10.2)')") "('FRZCROW'", NTYPE
!                write(58, NMTESTFORMAT) (hp%FRZCROW(1, m), m = 1, NTYPE)
!            end if
!            write(58, *)
!            write(58, "('MESH_parameters_CLASS.ini')")
!            write(58, *)
!            write(58, '(2x, 6a4)') TITLE1, TITLE2, TITLE3, TITLE4, TITLE5, TITLE6
!            write(58, '(2x, 6a4)') NAME1, NAME2, NAME3, NAME4, NAME5, NAME6
!            write(58, '(2x, 6a4)') PLACE1, PLACE2, PLACE3, PLACE4, PLACE5, PLACE6
!            i = 1
!            write(58, '(5f10.2, f7.1, 3i5)') &
!                DEGLAT, DEGLON, cp%ZRFMGRD(i), cp%ZRFHGRD(i), cp%ZBLDGRD(i), cp%GCGRD(i), shd%wc%ILG, NA, NTYPE
!            do m = 1, NTYPE
!                write(58, '(9f8.3)') (cp%FCANROW(i, m, j), j = 1, ICAN + 1), (cp%PAMXROW(i, m, j), j = 1, ICAN)
!                write(58, '(9f8.3)') (cp%LNZ0ROW(i, m, j), j = 1, ICAN + 1), (cp%PAMNROW(i, m, j), j = 1, ICAN)
!                write(58, '(9f8.3)') (cp%ALVCROW(i, m, j), j = 1, ICAN + 1), (cp%CMASROW(i, m, j), j = 1, ICAN)
!                write(58, '(9f8.3)') (cp%ALICROW(i, m, j), j = 1, ICAN + 1), (cp%ROOTROW(i, m, j), j = 1, ICAN)
!                write(58, '(4f8.3, 8x, 4f8.3)') (cp%RSMNROW(i, m, j), j = 1, ICAN), (cp%QA50ROW(i, m, j), j = 1, ICAN)
!                write(58, '(4f8.3, 8x, 4f8.3)') (cp%VPDAROW(i, m, j), j = 1, ICAN), (cp%VPDBROW(i, m, j), j = 1, ICAN)
!                write(58, '(4f8.3, 8x, 4f8.3)') (cp%PSGAROW(i, m, j), j = 1, ICAN), (cp%PSGBROW(i, m, j), j = 1, ICAN)
!                write(58, '(3f8.3, f8.4)') cp%DRNROW(i, m), cp%SDEPROW(i, m), cp%FAREROW(i, m), cp%DDROW(i, m)
!                write(58, '(4e8.1, i8)') cp%XSLPROW(i, m), cp%XDROW(i, m), cp%MANNROW(i, m), cp%KSROW(i, m), cp%MIDROW(i, m)
!                write(58, '(6f10.1)') (cp%SANDROW(i, m, j), j = 1, NSL)
!                write(58, '(6f10.1)') (cp%CLAYROW(i, m, j), j = 1, NSL)
!                write(58, '(6f10.1)') (cp%ORGMROW(i, m, j), j = 1, NSL)
!                write(58, '(9f10.2)') (cp%TBARROW(i, m, j), j = 1, NSL), cp%TCANROW(i, m), cp%TSNOROW(i, m), cp%TPNDROW(i, m)
!                write(58, '(10f10.3)') &
!                    (cp%THLQROW(i, m, j), j = 1, NSL), (cp%THICROW(i, m, j), j = 1, NSL), cp%ZPNDROW(i, m)
!                write(58, '(2f10.4, f10.2, f10.3, f10.4, f10.3, f10.3)') &
!                    cp%RCANROW(i, m), cp%SCANROW(i, m), cp%SNOROW(i, m), cp%ALBSROW(i, m), cp%RHOSROW(i, m), cp%GROROW(i, m)
!                write(58, *)
!            end do !m = 1, NTYPE
        end if !(MODELINFOOUTFLAG > 0) then
    end if !(ipid == 0) then

    !> Open and print header information to the output files
    !> Open and read in values from r2c_output.txt file
    if (ipid == 0) then
        NR2CFILES = 0
        if (R2COUTPUTFLAG >= 1) then
            inquire(file = 'r2c_output.txt', exist = R2COUTPUT)
            if (R2COUTPUT) then
                open(56, file = 'r2c_output.txt', action = 'read')
                read(56, *, iostat = ierr) NR2C, DELTR2C
                if (ierr == 0) then
                    allocate(GRD(NR2C), GAT(NR2C), GRDGAT(NR2C), R2C_ATTRIBUTES(NR2C, 3), stat = ierr)
                    if (ierr /= 0) then
                        print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
                            'RECORD AT THE FIRST LINE IN THE r2c_output.txt FILE. ', &
                            'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
                        stop
                    end if
                end if
                if (ierr /= 0 .or. mod(DELTR2C, 30) /= 0) then
                    print 9002
                    stop
                end if
                print *
                print *, 'THE FOLLOWING R2C OUTPUT FILES WILL BE WRITTEN:'
                do i = 1, NR2C
                    read(56, *, iostat = ierr) GRD(i), GAT(i), GRDGAT(i), (R2C_ATTRIBUTES(i, j), j = 1, 3)
                    if (ierr /= 0) then
                        print *, 'ERROR READING r2c_output.txt FILE AT LINE ', i + 1
                        stop
                    else
                        if (GRD(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRD)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GAT)    : ', R2C_ATTRIBUTES(i, 3)
                        end if
                        if (GRDGAT(i) == 1) then
                            NR2CFILES = NR2CFILES + 1
                            print *, NR2CFILES, ' (GRDGAT) : ', R2C_ATTRIBUTES(i, 3)
                        end if
                    end if
                end do
                close(56)
            else
                print *
                print *, "r2c_output.txt FILE DOESN'T EXIST. ", &
                    'R2COUTPUTFLAG SHOULD BE SET TO ZERO IF R2C OUTPUTS ARE NOT NEEDED.'
                print *
                stop
            end if
        end if

        !> WRITE THE HEADER FOR R2C FILES:
        if (NR2CFILES > 0) then
            call WRITE_R2C_HEADER(NTYPE, NR2C, NR2CFILES, GRD, GAT, GRDGAT, R2C_ATTRIBUTES, &
                                  R2CFILEUNITSTART, NR2CSTATES, shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
                                  shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta, shd%xCount, shd%yCount)
        end if

        !> For the ENSIM timestamp
        wfo_seq = 0

    end if !(ipid == 0) then

    !> *********************************************************************
    !> Output diagnostic information to screen.
    !> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *, 'NUMBER OF GRID SQUARES: ', NA
        print *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NTYPE
        print *, 'NUMBER OF RIVER CLASSES: ', shd%NRVR
        print *, 'MINIMUM NUMBER FOR ILG: ', shd%lc%ILG
        print *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', shd%xCount
        print *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', shd%yCount
        print *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', shd%AL
        print *, 'NUMBER OF DRAINAGE OUTLETS: ', (NA - shd%NAA)
        print *
        print *
        print *
    end if !(ro%VERBOSEMODE > 0) then

    !> RESUME/SAVERESUME 1 or 2 are not supported.
    if (ipid == 0) then
        if (RESUMEFLAG == 1 .or. SAVERESUMEFLAG == 1 .or. RESUMEFLAG == 2 .or. SAVERESUMEFLAG == 2) then
            print 679, RESUMEFLAG, SAVERESUMEFLAG
            stop
        end if
    end if

679     format(/ &
               /1x, 'RESUMEFLAG ', i1, ' and SAVERESUMEFLAG ', i1, ' are not supported.', &
               /1x, 'Use RESUMEFLAG 4 or SAVERESUMEFLAG 4 instead.', &
               /1x, 'Individual variables for RESUME/SAVERESUME or the file format', &
               /1x, 'of the resume files cannot be configured at this time.')

!> ********************************************************************
!> RESUMEFLAG
!> ********************************************************************

      !> Check if we are reading in a resume_state.r2c file
!+    if (RESUMEFLAG == 2) then
!+        print *, 'Reading saved state variables'

          !> Allocate arrays for resume_state_r2c
!+        open(54, file = 'resume_state_r2c.txt', action = 'read')
!+        read(54, *, iostat = ierr) NR2C_R, DELTR2C_R
!+        if (ierr == 0) then
!+            allocate(GRD_R(NR2C_R), GAT_R(NR2C_R), GRDGAT_R(NR2C_R), R2C_ATTRIBUTES_R(NR2C_R, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
!+                    'RECORD AT THE FIRST LINE IN THE resume_state_r2c.txt FILE. ', &
!+                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
!+                stop
!+            end if
!+        end if
!+        close(54)

         !> start by gathering from ROW to GAT so as not to mess-up with CLASSS after call to save_state_r2c
!        call CLASSG (cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                     cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                     cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, FRZCGAT, cpv%CMAI, &
!                     csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!                     csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!                     csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!                     csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!                     csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!                     csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, csfv%IGDR, &
!                     csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, cfi%VMOD, &
!                     csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!                     csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!                     csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!                     csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!                     catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!                     cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!                     cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!                     catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!                     catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!                     catv%GGEO, &
!                     cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!                     cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!                     cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!                     cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!                     cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!                     cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!                     cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!                     cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!                     cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!                     cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!                     cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!                     cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!                     cdv%HMFG, cdv%HTC, cdv%QFC, ITCTGAT, &
!BEGIN: PDMROF
!                     CMINPDM, CMAXPDM, BPDM, K1PDM, K2PDM, &
!END: PDMROF
!                     shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, NA, NTYPE, &
!                     NML, il1, il2, NSL, ICAN, ICP1, cp%TBARROW, cp%THLQROW, &
!                     cp%THICROW, cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, &
!                     cp%TSNOROW, cp%RHOSROW, cp%SNOROW, cp%TCANROW, &
!                     cp%RCANROW, cp%SCANROW, cp%GROROW, CMAIROW, cp%FCANROW, &
!                     cp%LNZ0ROW, cp%ALVCROW, cp%ALICROW, cp%PAMXROW, &
!                     cp%PAMNROW, cp%CMASROW, cp%ROOTROW, cp%RSMNROW, &
!                     cp%QA50ROW, cp%VPDAROW, cp%VPDBROW, cp%PSGAROW, &
!                     cp%PSGBROW, PAIDROW, HGTDROW, ACVDROW, ACIDROW, TSFSROW, &
!                     WSNOROW, THPROW, THRROW, THMROW, BIROW, PSISROW, &
!                     GRKSROW, THRAROW, HCPSROW, TCSROW, IGDRROW, &
!                     THFCROW, PSIWROW, DLZWROW, ZBTWROW, VMODGRD, &
!                     hp%ZSNLROW, hp%ZPLGROW, hp%ZPLSROW, hp%FRZCROW, TACROW, QACROW, &
!                     cp%DRNROW, cp%XSLPROW, cp%XDROW, WFSFROW, cp%KSROW, &
!                     ALGWROW, ALGDROW, ASVDROW, ASIDROW, AGVDROW, &
!                     AGIDROW, ISNDROW, RADJGRD, cp%ZBLDGRD, Z0ORGRD, &
!                     cp%ZRFMGRD, cp%ZRFHGRD, ZDMGRD, ZDHGRD, cm%dat(ck%FB)%GRD/2.0, &
!                     cm%dat(ck%FB)%GRD/2.0, CSZGRD, cm%dat(ck%FI)%GRD, cm%dat(ck%UV)%GRD, VLGRD, &
!                     cm%dat(ck%TT)%GRD, cm%dat(ck%HU)%GRD, cm%dat(ck%P0)%GRD, &
!                     cm%dat(ck%RT)%GRD, PADRGRD, &
!                     VPDGRD, TADPGRD, RHOAGRD, RPCPGRD, TRPCGRD, &
!                     SPCPGRD, TSPCGRD, RHSIGRD, FCLOGRD, DLONGRD, &
!                     GGEOGRD, cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                     cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, &
!BEGIN: PDMROF
!                     hp%CMINROW, hp%CMAXROW, hp%BROW, hp%K1ROW, hp%K2ROW, &
!END: PDMROF
!                     cp%FAREROW, csfv%FARE, &
!                     hp%fetchROW, hp%HtROW, hp%N_SROW, hp%A_SROW, hp%DistribROW, &
!                     fetchGAT, HtGAT, N_SGAT, A_SGAT, DistribGAT, &
!                     DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                     TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                     DriftROW, SublROW, DepositionROW, &
!                     DriftGAT, SublGAT, DepositionGAT)

!        cdv%CDH = 0.0
!        cdv%CDM = 0.0
!        cdv%HFS = 0.0
!        cdv%TFX = 0.0
!        cdv%QEVP = 0.0
!        cdv%QFS = 0.0
!        cdv%QFX = 0.0
!        cdv%PET = 0.0
!        cdv%GA = 0.0
!        cdv%EF = 0.0
!        cdv%GTE = 0.0
!        cdv%QG = 0.0
!        cdv%ALVS = 0.0
!        cdv%ALIR = 0.0
!        cdv%SFCT = 0.0
!        cdv%SFCU = 0.0
!        cdv%SFCV = 0.0
!        cdv%SFCQ = 0.0
!        cdv%FSNO = 0.0
!        cdv%FSGV = 0.0
!        cdv%FSGS = 0.0
!        cdv%FSGG = 0.0
!        cdv%FLGV = 0.0
!        cdv%FLGS = 0.0
!        cdv%FLGG = 0.0
!        cdv%HFSC = 0.0
!        cdv%HFSS = 0.0
!        cdv%HFSG = 0.0
!        cdv%HEVC = 0.0
!        cdv%HEVS = 0.0
!        cdv%HEVG = 0.0
!        cdv%HMFC = 0.0
!        cdv%HMFN = 0.0
!        cdv%HTCC = 0.0
!        cdv%HTCS = 0.0
!        cdv%PCFC = 0.0
!        cdv%PCLC = 0.0
!        cdv%PCPN = 0.0
!        cdv%PCPG = 0.0
!        cdv%QFG = 0.0
!        cdv%QFN = 0.0
!        cdv%QFCF = 0.0
!        cdv%QFCL = 0.0
!        cdv%ROF = 0.0
!        cdv%ROFO = 0.0
!        cdv%ROFS = 0.0
!        cdv%ROFB = 0.0
!        cdv%TROF = 0.0
!        cdv%TROO = 0.0
!        cdv%TROS = 0.0
!        cdv%TROB = 0.0
!        cdv%ROFC = 0.0
!        cdv%ROFN = 0.0
!        cdv%ROVG = 0.0
!        cdv%WTRC = 0.0
!        cdv%WTRS = 0.0
!        cdv%WTRG = 0.0
!        cdv%DR = 0.0
!        cdv%HMFG = 0.0
!        cdv%HTC = 0.0
!        cdv%QFC = 0.0
!        cdv%GFLX = 0.0
!        ITCTGAT = 0

!+        call resume_state_r2c(shd%lc%NML, NA, NTYPE, ic%ts_daily, &
!+                              ic%now%mins, shd%lc%ACLASS, NR2C_R, GRD_R, GAT_R, GRDGAT_R, R2C_ATTRIBUTES_R, &
!+                              NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, NSL, &
!+                              cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                              cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                              cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                              csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                              csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                              csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                              csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                              csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                              csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                              csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                              csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                              csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                              csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                              csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                              catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                              cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                              cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                              catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                              catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                              catv%GGEO, &
!+                              cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                              cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                              cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                              cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                              cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                              cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                              cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                              cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                              cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                              cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                              cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                              cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                              cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                              csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                              shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                              shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)

         !> now scatter the variables so that the GATs don't get overwritten incorrectly
!        call CLASSS(cp%TBARROW, cp%THLQROW, cp%THICROW, GFLXROW, TSFSROW, &
!                    cp%TPNDROW, cp%ZPNDROW, TBASROW, cp%ALBSROW, cp%TSNOROW, &
!                    cp%RHOSROW, cp%SNOROW, cp%TCANROW, cp%RCANROW, cp%SCANROW, &
!                    cp%GROROW, CMAIROW, TACROW, QACROW, WSNOROW, &
!                    shd%lc%ILMOS, shd%lc%JLMOS, shd%wc%ILMOS, shd%wc%JLMOS, &
!                    NA, NTYPE, NML, il1, il2, NSL, ICAN, ICAN + 1, &
!                    cpv%TBAR, cpv%THLQ, cpv%THIC, cdv%GFLX, cpv%TSFS, &
!                    cpv%TPND, cpv%ZPND, cpv%TBAS, cpv%ALBS, cpv%TSNO, &
!                    cpv%RHOS, cpv%SNO, cpv%TCAN, cpv%RCAN, cpv%SNCAN, &
!                    cpv%GRO, cpv%CMAI, cpv%TAC, cpv%QAC, cpv%WSNO, &
!                    cp%MANNROW, MANNGAT, cp%DDROW, DDGAT, &
!                    cp%SANDROW, csfv%SAND, cp%CLAYROW, csfv%CLAY, cp%XSLPROW, csfv%XSLP, &
!                    DrySnowRow, SnowAgeROW, DrySnowGAT, SnowAgeGAT, &
!                    TSNOdsROW, RHOSdsROW, TSNOdsGAT, RHOSdsGAT, &
!                    DriftROW, SublROW, DepositionROW, &
!                    DriftGAT, SublGAT, DepositionGAT)

!        do 180 k = il1, il2
!            ik = shd%lc%ILMOS(k)
!            jk = shd%lc%JLMOS(k)
!            CDHROW(ik, jk) = cdv%CDH(k)
!            CDMROW(ik, jk) = cdv%CDM(k)
!            HFSROW(ik, jk) = cdv%HFS(k)
!            TFXROW(ik, jk) = cdv%TFX(k)
!            QEVPROW(ik, jk) = cdv%QEVP(k)
!            QFSROW(ik, jk) = cdv%QFS(k)
!            QFXROW(ik, jk) = cdv%QFX(k)
!            PETROW(ik, jk) = cdv%PET(k)
!            GAROW(ik, jk) = cdv%GA(k)
!            EFROW(ik, jk) = cdv%EF(k)
!            GTROW(ik, jk) = cdv%GTE(k)
!            QGROW(ik, jk) = cdv%QG(k)
!            ALVSROW(ik, jk) = cdv%ALVS(k)
!            ALIRROW(ik, jk) = cdv%ALIR(k)
!            SFCTROW(ik, jk) = cdv%SFCT(k)
!            SFCUROW(ik, jk) = cdv%SFCU(k)
!            SFCVROW(ik, jk) = cdv%SFCV(k)
!            SFCQROW(ik, jk) = cdv%SFCQ(k)
!            FSNOROW(ik, jk) = cdv%FSNO(k)
!            FSGVROW(ik, jk) = cdv%FSGV(k)
!            FSGSROW(ik, jk) = cdv%FSGS(k)
!            FSGGROW(ik, jk) = cdv%FSGG(k)
!            FLGVROW(ik, jk) = cdv%FLGV(k)
!            FLGSROW(ik, jk) = cdv%FLGS(k)
!            FLGGROW(ik, jk) = cdv%FLGG(k)
!            HFSCROW(ik, jk) = cdv%HFSC(k)
!            HFSSROW(ik, jk) = cdv%HFSS(k)
!            HFSGROW(ik, jk) = cdv%HFSG(k)
!            HEVCROW(ik, jk) = cdv%HEVC(k)
!            HEVSROW(ik, jk) = cdv%HEVS(k)
!            HEVGROW(ik, jk) = cdv%HEVG(k)
!            HMFCROW(ik, jk) = cdv%HMFC(k)
!            HMFNROW(ik, jk) = cdv%HMFN(k)
!            HTCCROW(ik, jk) = cdv%HTCC(k)
!            HTCSROW(ik, jk) = cdv%HTCS(k)
!            PCFCROW(ik, jk) = cdv%PCFC(k)
!            PCLCROW(ik, jk) = cdv%PCLC(k)
!            PCPNROW(ik, jk) = cdv%PCPN(k)
!            PCPGROW(ik, jk) = cdv%PCPG(k)
!            QFGROW(ik, jk) = cdv%QFG(k)
!            QFNROW(ik, jk) = cdv%QFN(k)
!            QFCLROW(ik, jk) = cdv%QFCL(k)
!            QFCFROW(ik, jk) = cdv%QFCF(k)
!            ROFROW(ik, jk) = cdv%ROF(k)
!            ROFOROW(ik, jk) = cdv%ROFO(k)
!            ROFSROW(ik, jk) = cdv%ROFS(k)
!            ROFBROW(ik, jk) = cdv%ROFB(k)
!            TROFROW(ik, jk) = cdv%TROF(k)
!            TROOROW(ik, jk) = cdv%TROO(k)
!            TROSROW(ik, jk) = cdv%TROS(k)
!            TROBROW(ik, jk) = cdv%TROB(k)
!            ROFCROW(ik, jk) = cdv%ROFC(k)
!            ROFNROW(ik, jk) = cdv%ROFN(k)
!            ROVGROW(ik, jk) = cdv%ROVG(k)
!            WTRCROW(ik, jk) = cdv%WTRC(k)
!            WTRSROW(ik, jk) = cdv%WTRS(k)
!            WTRGROW(ik, jk) = cdv%WTRG(k)
!            DRROW(ik, jk) = cdv%DR(k)
!            WTABROW(ik, jk) = cdv%WTAB(k)
!            ILMOROW(ik, jk) = cdv%ILMO(k)
!            UEROW(ik, jk) = cdv%UE(k)
!            HBLROW(ik, jk) = cdv%HBL(k)
!180     continue

!        do 190 l = 1, NSL
!            do 190 k = il1, il2
!                ik = shd%lc%ILMOS(k)
!                jk = shd%lc%JLMOS(k)
!                HMFGROW(ik, jk, l) = cdv%HMFG(k, l)
!                HTCROW(ik, jk, l) = cdv%HTC(k, l)
!                QFCROW(ik, jk, l) = cdv%QFC(k, l)
!190     continue

!        do 230 m = 1, 50
!            do 220 l = 1, 6
!                do 210 k = il1, il2
!                    ITCTROW(shd%lc%ILMOS(k), shd%lc%JLMOS(k), l, m) = ITCTGAT(k, l, m)
!210     continue
!220     continue
!230     continue
!+    end if !(RESUMEFLAG == 2) then

    if (ipid == 0) then

        !> Initialize accumulation variables.
        wb_acc%PRE = 0.0
        eb_acc%QEVP = 0.0
        wb_acc%EVAP = 0.0
        eb_acc%HFS = 0.0
        wb_acc%ROF = 0.0
        wb_acc%ROFO = 0.0
        wb_acc%ROFS = 0.0
        wb_acc%ROFB = 0.0
        spv_acc%TBAR = 0.0
        spv_acc%THLQ = 0.0
        wb_acc%LQWS = 0.0
        spv_acc%THIC = 0.0
        wb_acc%FRWS = 0.0
        eb_acc%GFLX = 0.0
        wb_acc%RCAN = 0.0
        wb_acc%SNCAN = 0.0
        wb_acc%SNO = 0.0
        wb_acc%WSNO = 0.0
        wb_acc%PNDW = 0.0
        wb_acc%STG = 0.0
        wb_acc%DSTG = 0.0

    end if !(ipid == 0) then

    !> Calculate initial storage.
    if (ipid == 0) then
        STG_INI = sum(wb_grd%stg)/wb_grd%basin_area
    end if !(ipid == 0) then

    !> Read in existing basin states for RESUMEFLAG.
    if (RESUMEFLAG == 4) then

        !> Open the resume file for the driver.
        iun = fls%fl(mfk%f883)%iun
        open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'old', action = 'read', &
             form = 'unformatted', access = 'sequential', iostat = ierr)
!todo: condition for ierr.

        !> Time-stepping information.
        read(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
        read(iun) ic%count_year, ic%count_jday, ic%count_month, ic%count_jday, ic%count_hour, ic%count_mins
        read(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count

        !> Read states for the driver (for the head node or in serial).
        if (ipid == 0) then

            !> Water balance totals.
            read(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
            read(iun) STG_INI

            !> Daily streamflow values.
            read(iun) stfl%qhyd
            read(iun) stfl%qsyn

        end if

        !> Close the file to free the unit.
        close(iun)

    end if !(RESUMEFLAG == 4) then

    if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(fls, stfl)

    !> *********************************************************************
    !> End of Initialization
    !> *********************************************************************

    if (ro%VERBOSEMODE > 0) then
        print *
        print 2836
        print 2835
    end if !(ro%VERBOSEMODE > 0) then

2836    format(/1x, 'DONE INTITIALIZATION')
2835    format(/1x, 'STARTING MESH')

    !> *********************************************************************
    !> Start of main loop that is run each half hour
    !> *********************************************************************

    !> MAM - Initialize ENDDATE and ENDDATA
!-    ENDDATE = .false.
!-    ENDDATA = .false.

    do while (.not. ENDDATE .and. .not. ENDDATA)

        !> Pass the run state from the head to worker nodes.
!+        if (inp > 1 .and. ipid /= 0) then

            !> Receive data from the head node.
!+            call MPI_Recv(RUNSTATE, 1, MPI_INT, 0, ipid, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)
!+        else if (inp > 1) then

            !> Send data for the worker nodes.
!+            do u = 1, (inp - 1)
!+                call MPI_Send(RUNSTATE, 1, MPI_INT, u, u, MPI_COMM_WORLD, ierr)
!+            end do
!+        end if !(inp > 1 .and. ipid /= 0) then

!-        if (inp > 1 .and. ic%ts_daily == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

        if (RUNSTATE /= 0) exit

        !> Load or update climate forcing input.
        ENDDATA = climate_module_update_data(fls, shd, il1, il2, cm)
        if (ENDDATA) then
            RUNSTATE = 1
            cycle
        end if

        !> Reset variables that accumulate on the daily time-step.
        if (ipid == 0 .and. ic%ts_daily == 1) then
            wb_acc%PRE = 0.0
            eb_acc%QEVP = 0.0
            wb_acc%EVAP = 0.0
            eb_acc%HFS = 0.0
            wb_acc%ROF = 0.0
            wb_acc%ROFO = 0.0
            wb_acc%ROFS =  0.0
            wb_acc%ROFB = 0.0
            spv_acc%TBAR = 0.0
            spv_acc%THLQ = 0.0
            wb_acc%LQWS = 0.0
            spv_acc%THIC = 0.0
            wb_acc%FRWS = 0.0
            eb_acc%GFLX = 0.0
            wb_acc%RCAN = 0.0
            wb_acc%SNCAN = 0.0
            wb_acc%SNO = 0.0
            wb_acc%WSNO = 0.0
            wb_acc%PNDW = 0.0
        end if

        !> Reset variables.
        if (ipid == 0) then
            wb_grd%PRE = 0.0
            eb_grd%QEVP = 0.0
            wb_grd%EVAP = 0.0
            wb_grd%pevp = 0.0
            wb_grd%evpb = 0.0
            eb_grd%HFS = 0.0
            wb_grd%ROF = 0.0
            wb_grd%ROFO = 0.0
            wb_grd%ROFS =  0.0
            wb_grd%ROFB = 0.0
            spv_grd%TBAR = 0.0
            spv_grd%THLQ = 0.0
            wb_grd%LQWS = 0.0
            spv_grd%THIC = 0.0
            wb_grd%FRWS = 0.0
            eb_grd%GFLX = 0.0
            wb_grd%RCAN = 0.0
            wb_grd%SNCAN = 0.0
            wb_grd%SNO = 0.0
            wb_grd%WSNO = 0.0
            wb_grd%PNDW = 0.0
            wb_grd%DSTG = wb_grd%STG
            wb_grd%STG = 0.0
        end if

        cstate = run_within_tile(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
        if (len_trim(cstate) > 0) then
            RUNSTATE = 1
            cycle
        end if

        call run_within_grid(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

        !> *********************************************************************
        !> Start of book-keeping and grid accumulation.
        !> *********************************************************************

        if (ipid == 0) then

            !> Write ENSIM output
            if (NR2CFILES > 0 .and. mod(ic%ts_daily*30, DELTR2C) == 0) then
!                call FIND_MONTH (ic%now%jday, ic%now%year, ensim_month)
!                call FIND_DAY (ic%now%jday, ic%now%year, ensim_day)
!                call WRITE_R2C_DATA(shd%lc%NML, NA, NTYPE, ic%ts_daily, ic%now%mins, shd%lc%ACLASS, &
!                                    NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, &
!                                    NR2C, NR2CFILES, R2CFILEUNITSTART, GRD, GAT, &
!                                    GRDGAT, NR2CSTATES, R2C_ATTRIBUTES, FRAME_NO_NEW, ic%now%year, &
!                                    ensim_MONTH, ensim_DAY, ic%now%hour, ic%now%mins, ICAN, &
!                                    ICAN + 1, NSL, &
!                                    cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!                                    cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!                                    cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!                                    csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!                                    csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!                                    csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!                                    csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!                                    csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!                                    csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!                                    csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!                                    csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!                                    csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!                                    csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!                                    csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!                                    catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!                                    cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!                                    cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!                                    catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!                                    catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!                                    catv%GGEO, &
!                                    cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!                                    cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!                                    cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!                                    cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!                                    cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!                                    cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!                                    cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!                                    cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!                                    cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!                                    cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!                                    cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!                                    cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!                                    cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!                                    csfv%IGDR, cfi%VMOD, QLWOGAT)
                FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS
            end if

            !> CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

            !> Grid data for output.
            md_grd%fsdown = cm%dat(ck%FB)%GRD
            md_grd%fsvh = cm%dat(ck%FB)%GRD/2.0
            md_grd%fsih = cm%dat(ck%FB)%GRD/2.0
            md_grd%fdl = cm%dat(ck%FI)%GRD
            md_grd%ul = cm%dat(ck%UV)%GRD
            md_grd%ta = cm%dat(ck%TT)%GRD
            md_grd%qa = cm%dat(ck%HU)%GRD
            md_grd%pres = cm%dat(ck%P0)%GRD
            md_grd%pre = cm%dat(ck%RT)%GRD

!-            do k = il1, il2
!-                ik = shd%lc%ILMOS(k)
!-                FRAC = shd%lc%ACLASS(ik, shd%lc%JLMOS(k))*shd%FRAC(ik)
!-                if (FRAC > 0.0) then
!-                    wb_grd%PRE(ik) = wb_grd%PRE(ik) + cfi%PRE(k)*FRAC*ic%dts
!-                    eb_grd%QEVP(ik) = eb_grd%QEVP(ik) + cdv%QEVP(k)*FRAC
!-                    wb_grd%EVAP(ik) = wb_grd%EVAP(ik) + cdv%QFS(k)*FRAC*ic%dts
!-                    eb_grd%HFS(ik)  = eb_grd%HFS(ik) + cdv%HFS(k)*FRAC
!-                    wb_grd%ROF(ik) = wb_grd%ROF(ik) + cdv%ROF(k)*FRAC*ic%dts
!-                    wb_grd%ROFO(ik) = wb_grd%ROFO(ik) + cdv%ROFO(k)*FRAC*ic%dts
!-                    wb_grd%ROFS(ik) = wb_grd%ROFS(ik) + cdv%ROFS(k)*FRAC*ic%dts
!-                    wb_grd%ROFB(ik) = wb_grd%ROFB(ik) + cdv%ROFB(k)*FRAC*ic%dts
!-                    do j = 1, NSL
!-                        spv_grd%TBAR(ik, j) = spv_grd%TBAR(ik, j) + cpv%TBAR(k, j)*shd%lc%ACLASS(ik, shd%lc%JLMOS(k))
!-                        spv_grd%THLQ(ik, j) = spv_grd%THLQ(ik, j) + cpv%THLQ(k, j)*FRAC
!-                        wb_grd%LQWS(ik, j) = wb_grd%LQWS(ik, j) + cpv%THLQ(k, j)*csfv%DELZW(k, j)*FRAC*RHOW
!-                        spv_grd%THIC(ik, j) = spv_grd%THIC(ik, j) + cpv%THIC(k, j)*FRAC
!-                        wb_grd%FRWS(ik, j) = wb_grd%FRWS(ik, j) + cpv%THIC(k, j)*csfv%DELZW(k, j)*FRAC*RHOICE
!-                        eb_grd%GFLX(ik, j) = eb_grd%GFLX(ik, j) + cdv%GFLX(k, j)*FRAC
!-                    end do
!-                    wb_grd%RCAN(ik) = wb_grd%RCAN(ik) + cpv%RCAN(k)*FRAC
!-                    wb_grd%SNCAN(ik) = wb_grd%SNCAN(ik) + cpv%SNCAN(k)*FRAC
!-                    wb_grd%SNO(ik) = wb_grd%SNO(ik) + cpv%SNO(k)*FRAC
!-                    if (cpv%SNO(k) > 0.0) then
!-                        wb_grd%WSNO(ik) = wb_grd%WSNO(ik) + cpv%WSNO(k)*FRAC
!-                    end if
!-                    wb_grd%PNDW(ik) = wb_grd%PNDW(ik) + cpv%ZPND(k)*FRAC*RHOW
!-                end if
!-            end do !k = il1, il2

            wb_grd%DSTG = wb_grd%RCAN + wb_grd%SNCAN + wb_grd%SNO + wb_grd%WSNO + wb_grd%PNDW + &
                sum(wb_grd%LQWS, 2) + sum(wb_grd%FRWS, 2) - wb_grd%STG
            wb_grd%STG = wb_grd%DSTG + wb_grd%STG

            !> Update output data.
            if (OUTFIELDSFLAG == 1) call updatefieldsout_temp(shd, ts, ifo, &
                                                              md_grd, wb_grd, &
                                                              vr)

            !> Basin totals for the run.
            TOTAL_PRE = TOTAL_PRE + sum(wb_grd%PRE)
            TOTAL_EVAP = TOTAL_EVAP + sum(wb_grd%EVAP)
            TOTAL_ROF = TOTAL_ROF + sum(wb_grd%ROF)
            TOTAL_ROFO = TOTAL_ROFO + sum(wb_grd%ROFO)
            TOTAL_ROFS = TOTAL_ROFS + sum(wb_grd%ROFS)
            TOTAL_ROFB = TOTAL_ROFB + sum(wb_grd%ROFB)

            !> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.
            wb_acc%PRE = wb_acc%PRE + wb_grd%PRE
            eb_acc%QEVP = eb_acc%QEVP + eb_grd%QEVP
            wb_acc%EVAP = wb_acc%EVAP + wb_grd%EVAP
            eb_acc%HFS  = eb_acc%HFS + eb_grd%HFS
            wb_acc%ROF = wb_acc%ROF + wb_grd%ROF
            wb_acc%ROFO = wb_acc%ROFO + wb_grd%ROFO
            wb_acc%ROFS = wb_acc%ROFS + wb_grd%ROFS
            wb_acc%ROFB = wb_acc%ROFB + wb_grd%ROFB
            spv_acc%TBAR = spv_acc%TBAR + spv_grd%TBAR
            spv_acc%THLQ = spv_acc%THLQ + spv_grd%THLQ
            wb_acc%LQWS = wb_acc%LQWS + wb_grd%LQWS
            spv_acc%THIC = spv_acc%THIC + spv_grd%THIC
            wb_acc%FRWS = wb_acc%FRWS + wb_grd%FRWS
            eb_acc%GFLX = eb_acc%GFLX + eb_grd%GFLX
            wb_acc%RCAN = wb_acc%RCAN + wb_grd%RCAN
            wb_acc%SNCAN = wb_acc%SNCAN + wb_grd%SNCAN
            wb_acc%SNO = wb_acc%SNO + wb_grd%SNO
            wb_acc%WSNO = wb_acc%WSNO + wb_grd%WSNO
            wb_acc%PNDW = wb_acc%PNDW + wb_grd%PNDW

            !> CALCULATE AND PRINT DAILY AVERAGES.
            if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
                                        !when they're numbered 1-48

                eb_acc%QEVP = eb_acc%QEVP/real(ic%ts_daily)
                eb_acc%HFS = eb_acc%HFS/real(ic%ts_daily)
                spv_acc%TBAR = spv_acc%TBAR/real(ic%ts_daily)
                spv_acc%THLQ = spv_acc%THLQ/real(ic%ts_daily)
                wb_acc%LQWS = wb_acc%LQWS/real(ic%ts_daily)
                spv_acc%THIC = spv_acc%THIC/real(ic%ts_daily)
                wb_acc%FRWS = wb_acc%FRWS/real(ic%ts_daily)
                eb_acc%GFLX = eb_acc%GFLX/real(ic%ts_daily)
                wb_acc%RCAN = wb_acc%RCAN/real(ic%ts_daily)
                wb_acc%SNCAN = wb_acc%SNCAN/real(ic%ts_daily)
                wb_acc%SNO = wb_acc%SNO/real(ic%ts_daily)
                wb_acc%WSNO = wb_acc%WSNO/real(ic%ts_daily)
                wb_acc%PNDW = wb_acc%PNDW/real(ic%ts_daily)

                !> Calculate storage terms.
                wb_acc%DSTG = wb_grd%DSTG
                wb_acc%STG = wb_grd%STG

                if (OUTFIELDSFLAG == 1) then
                    call UpdateFIELDSOUT(vr, ts, ifo, &
                                         wb_acc%pre, wb_acc%evap, wb_acc%rof, wb_acc%dstg, &
                                         spv_acc%tbar, wb_acc%lqws, wb_acc%frws, &
                                         wb_acc%rcan, wb_acc%sncan, &
                                         wb_acc%pndw, wb_acc%sno, wb_acc%wsno, &
                                         eb_acc%gflx, eb_acc%hfs, eb_acc%qevp, &
                                         spv_acc%thlq, spv_acc%thic, &
                                         NSL, &
                                         ic%now%jday, ic%now%year)
                end if

            end if !(ic%ts_daily == 48) then

        end if !(ipid == 0) then

        if (ipid == 0) call run_between_grid(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

        if (ipid == 0) then

            !> Write output to the console.
            if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
                                        !when they're numbered 1-48

                if (ro%VERBOSEMODE > 0) then
                    write(6, '(2i5)', advance = 'no') ic%now%year, ic%now%jday
                    if (printoutstfl) then
                        do j = 1, stfl%ns
                            if (printoutqhyd) write(6, '(f10.3)', advance = 'no') stfl%qhyd(j)
                            write(6, '(f10.3)', advance = 'no') stfl%qsyn(j)
                        end do
                    end if
!todo: restore this or replace with basin total.
!                    j = ceiling(real(NA)/2); if (WF_NUM_POINTS > 0) j = op%N_OUT(1)
                    j = shd%NAA
                    if (printoutwb) write(6, '(3(f10.3))', advance = 'no') wb_acc%pre(j), wb_acc%evap(j), wb_acc%rof(j)
                    write(6, *)
                end if !(ro%VERBOSEMODE > 0) then
                if (mtsflg%AUTOCALIBRATIONFLAG > 0) then
                    call stats_update_stfl_daily(fls, stfl)
                    if (mtsflg%PREEMPTIONFLAG > 1) then
                        if (FTEST > FBEST) goto 199
                    end if
                end if

            end if !(ic%ts_daily == 48) then
        end if !(ipid == 0) then

5176    format(2i5, 999(f10.3))

        !> Update time counters and return to beginning of main loop
!-        ic%now%mins = ic%now%mins + ic%dtmins ! increment the current time by 30 minutes
!-        if (ic%now%mins == 60) then
!-            ic%now%mins = 0
!-            ic%now%hour = ic%now%hour + 1
!-            if (ic%now%hour == 24) then
!-                ic%now%hour = 0
!-                ic%now%jday = ic%now%jday + 1
!-                if (ic%now%jday >= 366) then
!-                    if (mod(ic%now%year, 400) == 0) then !LEAP YEAR
!-                        if (ic%now%jday == 367) then
!-                            ic%now%jday = 1
!-                            ic%now%year = ic%now%year + 1
!-                        end if
!-                    else if (mod(ic%now%year, 100) == 0) then !NOT A LEAP YEAR
!-                        ic%now%jday = 1
!-                        ic%now%year = ic%now%year + 1
!-                    else if (mod(ic%now%year, 4) == 0) then !LEAP YEAR
!-                        if (ic%now%jday == 367) then
!-                            ic%now%jday = 1
!-                            ic%now%year = ic%now%year + 1
!-                        end if
!-                    else !NOT A LEAP YEAR
!-                        ic%now%jday = 1
!-                        ic%now%year = ic%now%year + 1
!-                    end if
!-                end if
!-            end if
!-        end if

        !> Update the current time-step and counter.
        call counter_update()

        !> Check if we should terminate the run yet.
        if (ic%now%year >= ic%stop%year .and. ic%stop%year > 0) then
            if (ic%now%year > ic%stop%year) then
                ENDDATE = .true.
            else if (ic%now%year == ic%stop%year .and. ic%now%jday >= ic%stop%jday) then
                if (ic%now%jday > ic%stop%jday) then
                    ENDDATE = .true.
                else if (ic%now%jday == ic%stop%jday .and. ic%now%hour >= ic%stop%hour) then
                    if (ic%now%hour > ic%stop%hour) then
                        ENDDATE = .true.
                    else if (ic%now%hour == ic%stop%hour .and. ic%now%mins >= ic%stop%mins) then
                        ENDDATE = .true.
                    end if
                end if
            end if
        end if

        !> Check the run state.
        if (ENDDATA .or. ENDDATE) then
            RUNSTATE = 1
            exit
        end if

        !> Pass the run state from the worker to head nodes.
!+        if (inp > 1 .and. ipid /= 0) then

            !> Receive data from the head node.
!+            call MPI_Send(RUNSTATE, 1, MPI_INT, 0, ipid, MPI_COMM_WORLD, ierr)
!+        else if (inp > 1) then

            !> Send data for the worker nodes.
!+            do u = 1, (inp - 1)
!+                call MPI_Recv(irecv, 1, MPI_INT, u, u, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)
!+                RUNSTATE = max(RUNSTATE, irecv)
!+            end do
!+        end if !(inp > 1 .and. ipid /= 0) then

!-        if (inp > 1 .and. ic%ts_daily == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

    end do !while (.not. ENDDATE .and. .not. ENDDATA)

    !>
    !> ENDDATA mark
    !>

997     continue

    !> End program if not the head node.
    if (ipid /= 0) then
        if (ro%DIAGNOSEMODE > 0) print 4696, ipid
        goto 999

4696    format (1x, 'Node ', i4, ' is exiting...')

    end if !(ipid /= 0) then

    !> *********************************************************************
    !> SAVERESUMEFLAG
    !> *********************************************************************

    !> Write the resume file
!+    if (SAVERESUMEFLAG == 2) then !todo: done: use a flag
!+        print *, 'Saving state variables in r2c file format'

    !> Allocate arrays for save_state_r2c
!+        open(55, file = 'save_state_r2c.txt', action = 'read')
!+        read(55, *, iostat = ierr) NR2C_S, DELTR2C_S
!+        if (ierr == 0) then
!+            allocate(GRD_S(NR2C_S), GAT_S(NR2C_S), GRDGAT_S(NR2C_S), R2C_ATTRIBUTES_S(NR2C_S, 3), stat = ierr)
!+            if (ierr /= 0) then
!+                print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
!+                    'RECORD AT THE FIRST LINE IN THE save_state_r2c.txt FILE. ', &
!+                    'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
!+                stop
!+            end if
!+        end if
!+        close(55)

!+        call SAVE_STATE_R2C(shd%lc%NML, NA, NTYPE, ic%ts_daily, &
!+                            ic%now%mins, shd%lc%ACLASS, NR2C_S, GRD_S, GAT_S, GRDGAT_S, R2C_ATTRIBUTES_S, &
!+                            NA, shd%xxx, shd%yyy, shd%xCount, shd%yCount, shd%lc%ILMOS, shd%lc%JLMOS, NML, ICAN, ICP1, NSL, &
!+                            cpv%TBAR, cpv%THLQ, cpv%THIC, cpv%TPND, cpv%ZPND, &
!+                            cpv%TBAS, cpv%ALBS, cpv%TSNO, cpv%RHOS, cpv%SNO, &
!+                            cpv%TCAN, cpv%RCAN, cpv%SNCAN, cpv%GRO, cpv%CMAI, &
!+                            csfv%FCAN, csfv%LNZ0, csfv%ALVC, csfv%ALIC, csfv%PAMX, &
!+                            csfv%PAMN, csfv%CMAS, csfv%ROOT, csfv%RSMN, csfv%QA50, &
!+                            csfv%VPDA, csfv%VPDB, csfv%PSGA, csfv%PSGB, csfv%PAID, &
!+                            csfv%HGTD, csfv%ACVD, csfv%ACID, cpv%TSFS, cpv%WSNO, &
!+                            csfv%THP, csfv%THR, csfv%THM, csfv%BI, csfv%PSIS, &
!+                            csfv%GRKS, csfv%THRA, csfv%HCPS, csfv%TCS, &
!+                            csfv%THFC, csfv%PSIW, csfv%DELZW, csfv%ZBTW, &
!+                            csfv%ZSNL, csfv%ZPLG, csfv%ZPLS, cpv%TAC, cpv%QAC, &
!+                            csfv%DRN, csfv%XSLP, XDGAT, csfv%WFSF, KSGAT, &
!+                            csfv%ALGW, csfv%ALGD, csfv%ASVD, csfv%ASID, csfv%AGVD, &
!+                            csfv%AGID, csfv%ISND, catv%RADJ, catv%ZBLD, catv%Z0OR, &
!+                            catv%ZRFM, catv%ZRFH, catv%ZDM, catv%ZDH, cfi%FSVH, &
!+                            cfi%FSIH, catv%CSZ, cfi%FDL, cfi%UL, cfi%VL, &
!+                            cfi%TA, cfi%QA, cfi%PRES, cfi%PRE, catv%PADR, &
!+                            catv%VPD, catv%TADP, catv%RHOA, catv%RPCP, catv%TRPC, &
!+                            catv%SPCP, catv%TSPC, catv%RHSI, catv%FCLO, catv%DLON, &
!+                            catv%GGEO, &
!+                            cdv%CDH, cdv%CDM, cdv%HFS, cdv%TFX, cdv%QEVP, &
!+                            cdv%QFS, cdv%QFX, cdv%PET, cdv%GA, cdv%EF, &
!+                            cdv%GTE, cdv%QG, cdv%ALVS, cdv%ALIR, &
!+                            cdv%SFCT, cdv%SFCU, cdv%SFCV, cdv%SFCQ, cdv%FSNO, &
!+                            cdv%FSGV, cdv%FSGS, cdv%FSGG, cdv%FLGV, cdv%FLGS, &
!+                            cdv%FLGG, cdv%HFSC, cdv%HFSS, cdv%HFSG, cdv%HEVC, &
!+                            cdv%HEVS, cdv%HEVG, cdv%HMFC, cdv%HMFN, cdv%HTCC, &
!+                            cdv%HTCS, cdv%PCFC, cdv%PCLC, cdv%PCPN, cdv%PCPG, &
!+                            cdv%QFG, cdv%QFN, cdv%QFCL, cdv%QFCF, cdv%ROF, &
!+                            cdv%ROFO, cdv%ROFS, cdv%ROFB, cdv%TROF, cdv%TROO, &
!+                            cdv%TROS, cdv%TROB, cdv%ROFC, cdv%ROFN, cdv%ROVG, &
!+                            cdv%WTRC, cdv%WTRS, cdv%WTRG, cdv%DR, cdv%GFLX, &
!+                            cdv%HMFG, cdv%HTC, cdv%QFC, MANNGAT, DDGAT, &
!+                            csfv%SAND, csfv%CLAY, csfv%IGDR, cfi%VMOD, QLWOGAT, &
!+                            shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
!+                            shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta)
!+    end if !(SAVERESUMEFLAG == 2) then

    if (OUTFIELDSFLAG == 1) call write_outputs(shd, fls, ts, ifo, vr)

    !> *********************************************************************
    !> Run is now over, print final results to the screen and close files
    !> *********************************************************************

    if (ENDDATA) print *, 'Reached end of forcing data'
    if (ENDDATE) print *, 'Reached end of simulation date'

998     continue

    if (len_trim(cstate) > 0) print *, trim(cstate)

199 continue

    if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write(fls)

    !> Call finalization routines.
    call run_within_tile_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
    call run_within_grid_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
    call climate_module_finalize(fls, shd, cm)

    if (ipid == 0) then

        !> Call finalization routines.
        call run_between_grid_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)

        !> Save the current state of the model for SAVERESUMEFLAG.
        if (SAVERESUMEFLAG == 4) then

            !> Open the resume file for the driver.
            iun = fls%fl(mfk%f883)%iun
            open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'replace', action = 'write', &
                 form = 'unformatted', access = 'sequential', iostat = ierr)
!todo: condition for ierr.

            !> Time-stepping information.
            write(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
            write(iun) ic%count_year, ic%count_jday, ic%count_month, ic%count_jday, ic%count_hour, ic%count_mins
            write(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count

            !> Water balance totals.
            write(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
            write(iun) STG_INI

            !> Daily streamflow values.
            write(iun) stfl%qhyd
            write(iun) stfl%qsyn

            !> Close the file to free the unit.
            close(iun)

        end if !(SAVERESUMEFLAG == 4) then

        !> Calculate final storage for the run.
        STG_FIN = sum(wb_grd%stg)/wb_grd%basin_area

        !> Basin totals for the run.
        TOTAL_PRE = TOTAL_PRE/wb_grd%basin_area
        TOTAL_EVAP = TOTAL_EVAP/wb_grd%basin_area
        TOTAL_ROF = TOTAL_ROF/wb_grd%basin_area
        TOTAL_ROFO = TOTAL_ROFO/wb_grd%basin_area
        TOTAL_ROFS = TOTAL_ROFS/wb_grd%basin_area
        TOTAL_ROFB = TOTAL_ROFB/wb_grd%basin_area

        !> Write basin totals to screen.
        if (ro%VERBOSEMODE > 0) then

            print *
            print 5641, 'Total Precipitation         (mm) =', TOTAL_PRE
            print 5641, 'Total Evaporation           (mm) =', TOTAL_EVAP
            print 5641, 'Total Runoff                (mm) =', TOTAL_ROF
            print 5641, 'Storage (Change/Init/Final) (mm) =', (STG_FIN - STG_INI), STG_INI, STG_FIN
            print *
            print 5641, 'Total Overland flow         (mm) =', TOTAL_ROFO
            print 5641, 'Total Interflow             (mm) =', TOTAL_ROFS
            print 5641, 'Total Baseflow              (mm) =', TOTAL_ROFB
            print *

5641    format(3x, a34, 999(f11.3))
5635    format(1x, 'Program has terminated normally.'/)

        end if !(ro%VERBOSEMODE > 0) then

        print 5635

        !> Write data to the output summary file.
        if (MODELINFOOUTFLAG > 0) then

            !> CLASS states for prognostic variables.
            NTYPE = shd%lc%NTYPE
            NSL = shd%lc%IGND
            allocate(tcan(3, NTYPE), rcan(3, NTYPE), sncan(3, NTYPE), gro(3, NTYPE), zpnd(3, NTYPE), tpnd(3, NTYPE), &
                     sno(3, NTYPE), tsno(3, NTYPE), albs(3, NTYPE), rhos(3, NTYPE), &
                     tbar(3, NTYPE, NSL), thlq(3, NTYPE, NSL), thic(3, NTYPE, NSL), kc(NTYPE))
            tcan = 0.0; rcan = 0.0; sncan = 0.0; gro = 0.0; zpnd = 0.0; tpnd = 0.0
            sno = 0.0; tsno = 0.0; albs = 0.0; rhos = 0.0
            tbar = 0.0; thlq = 0.0; thic = 0.0; kc = 0

            !> Loop through the GRUs.
            do m = 1, NTYPE

                !> Cycle if the GRU does not exist.
                if (count(shd%lc%JLMOS(1:NML) == m) == 0) cycle

                !> Canopy.
                tcan(3, m) = maxval(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m)
                if (tcan(3, m) > 0.0) then
                    tcan(1, m) = sum(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m .and. &
                                     stas%cnpy%tcan /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%cnpy%tcan /= 0.0)
                    tcan(2, m) = minval(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m .and. stas%cnpy%tcan /= 0.0)
                end if
                where (tcan < 173.16 .or. tcan > 373.16 .or. tcan == 0.0) tcan = 273.16
                rcan(2, m) = minval(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)
                rcan(3, m) = maxval(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)
                rcan(1, m) = sum(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                sncan(2, m) = minval(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)
                sncan(3, m) = maxval(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)
                sncan(1, m) = sum(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                gro(2, m) = minval(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)
                gro(3, m) = maxval(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)
                gro(1, m) = sum(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)

                !> Ponded water at surface.
                zpnd(2, m) = minval(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)
                zpnd(3, m) = maxval(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)
                zpnd(1, m) = sum(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                tpnd(3, m) = maxval(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m)
                if (tpnd(3, m) > 0.0) then
                    tpnd(1, m) = sum(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m .and. &
                                     stas%sfc%tpnd /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sfc%tpnd /= 0.0)
                    tpnd(2, m) = minval(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m .and. stas%sfc%tpnd /= 0.0)
                end if
                where (tpnd < 173.16 .or. tpnd > 373.16 .or. tpnd == 0.0) tpnd = 273.16

                !> Snow.
                sno(2, m) = minval(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)
                sno(3, m) = maxval(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)
                sno(1, m) = sum(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                tsno(3, m) = maxval(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m)
                if (tsno(3, m) > 0.0) then
                    tsno(1, m) = sum(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m .and. &
                                     stas%sno%tsno /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%tsno /= 0.0)
                    tsno(2, m) = minval(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m .and. stas%sno%tsno /= 0.0)
                end if
                where (tsno < 173.16 .or. tsno > 373.16 .or. tsno == 0.0) tsno = 273.16
                if (sno(3, m) > 0.0) then
                    albs(1, m) = sum(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. &
                                     stas%sno%sno > 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
                    albs(2, m) = minval(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
                    albs(3, m) = maxval(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
                end if
                rhos(3, m) = maxval(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m)
                if (rhos(3, m) > 0.0) then
                    rhos(1, m) = sum(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m .and. &
                                     stas%sno%rhos /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%rhos /= 0.0)
                    rhos(2, m) = minval(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m .and. stas%sno%rhos /= 0.0)
                end if

                !> Soil.
                do j = 1, NSL
                    tbar(1, m, j) = sum(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    tbar(2, m, j) = minval(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
                    tbar(3, m, j) = maxval(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
                    thlq(1, m, j) = sum(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    thlq(2, m, j) = minval(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
                    thlq(3, m, j) = maxval(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
                    thic(1, m, j) = sum(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
                    thic(2, m, j) = minval(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)
                    thic(3, m, j) = maxval(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)
                end do
            end do

            !> Write to file.
            if (NRSOILAYEREADFLAG > 3) then
                ignd = min(NRSOILAYEREADFLAG, NSL)
            else if (NRSOILAYEREADFLAG == 1) then
                ignd = NSL
            else
                ignd = 3
            end if
            write(cfmt, '(i3)') ignd
            write(58, *)
            write(58, '(a)') 'End of run prognostic states'
            write(58, '(3x, (a), i4)') 'Number of GRUs: ', NTYPE
            do i = 1, 3
                write(58, *)
                select case (i)
                    case (1); write(58, '(a)') 'Average values'
                    case (2); write(58, '(a)') 'Minimum values'
                    case (3); write(58, '(a)') 'Maximum values'
                end select
                do m = 1, NTYPE
                    write(58, "(3x, 'GRU ', i3, ':')") m
                    cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), 3(f10.3), " // &
                            "2x, '!> TBAR(1:" // trim(adjustl(cfmt)) // ")/TCAN/TSNO/TPND')"
                    write(58, cfmtt) ((tbar(i, m, j) - 273.16), j = 1, ignd), &
                        (tcan(i, m) - 273.16), (tsno(i, m) - 273.16), (tpnd(i, m) - 273.16)
                    cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), " // trim(adjustl(cfmt)) // "(f10.3), f10.3, " // &
                            "2x, '!> THLQ(1:" // trim(adjustl(cfmt)) // ")/THIC(1:" // trim(adjustl(cfmt)) // ")/ZPND')"
                    write(58, cfmtt) (thlq(i, m, j), j = 1, ignd), (thic(i, m, j), j = 1, ignd), zpnd(i, m)
                    write(58, "(6(f10.3), 2x, '!> RCAN/SNCAN/SNO/ALBS/RHOS/GRO')") &
                        rcan(i, m), sncan(i, m), sno(i, m), albs(i, m), rhos(i, m), gro(i, m)
                end do
            end do

            !> Basin vertical water balance totals.
            write(58, *)
            write(58, '(a)') 'End of run totals'
            write(58, *)
            write(58, '(a, f11.3)') '  Total Precipitation         (mm) = ', TOTAL_PRE
            write(58, '(a, f11.3)') '  Total Evaporation           (mm) = ', TOTAL_EVAP
            write(58, '(a, f11.3)') '  Total Runoff                (mm) = ', TOTAL_ROF
            write(58, '(a, 3f11.3)') '  Storage(Change/Init/Final)  (mm) = ', (STG_FIN - STG_INI), STG_INI, STG_FIN
            write(58, '(a, f11.3)') '  Total Overland flow         (mm) = ', TOTAL_ROFO
            write(58, '(a, f11.3)') '  Total Interflow             (mm) = ', TOTAL_ROFS
            write(58, '(a, f11.3)') '  Total Baseflow              (mm) = ', TOTAL_ROFB
            write(58, *)

            !> Normal end of run message.
            write(58, *)
            write(58, '(a)') 'Program has terminated normally.'
            write(58, *)

            call cpu_time(endprog)
            write(58, "('Time = ', e14.6, ' seconds.')") (endprog - startprog)

        end if !(MODELINFOOUTFLAG > 0) then

    end if !(ipid == 0 ) then

999     continue

9002    format(/1x, 'ERROR IN READING r2c_output.txt FILE.', &
               /1x, 'THE FIRST RECORD AT THE FIRST LINE IS FOR THE NUMBER OF ALL THE', &
               /1x, 'VARIABLES LISTED IN THE r2c_output.txt FILE.',&
               /1x, 'THE SECOND RECORD AT THE FIRST LINE IS TIME STEP FOR R2C OUTPUT.', &
               /1x, 'IT SHOULD BE AN INTEGER MULTIPLE OF 30.',&
               /1x, 'THE REMAINING RECORDS SHOULD CONTAIN 3 COLUMNS FOR EACH VARIABLE WITH', &
               /1x, 'INTEGER VALUES OF EITHER 0 OR 1,', &
               /1x, 'AND 3 COLUMNS CONTAINING INFORMATION ABOUT THE VARIABLES.', /)

    call mpi_finalize(ierr)

    stop

end program

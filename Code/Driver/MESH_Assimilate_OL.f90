program MESH_Assimilate 
    
!>      MESH_Assimilate 
!>
!>       NOV 2015 - DGP. Moved incrementing the counters to
!>                  after routing has finished. This impacts when daily
!>                  and cumulative daily streamflow are written to file
!>                  and screen. The average daily streamflow was
!>                  calculated between 23:00-23:30 before the fix, tied
!>                  to an if statement about NCOUNT == 48, which
!>                  occurred shortly after NCOUNT = NCOUNT + 1 in the
!>                  same time-step. Average daily streamflow is
!>                  calculated between 23:30-24:00 after the fix. The
!>                  change causes results in MESH_output_streamflow.csv
!>                  and MESH_output_streamflow_cumulative.csv to differ
!>                  by the amount of flow calculated between
!>                  23:30-24:00. Metrics calculated based on streamflow
!>                  also change. The daily runoff generated by CLASS
!>                  remains unchanged.
!>                  Because metrics and streamflow results differ
!>                  between this and prior revisions, r909 might be
!>                  considered the start of MESH 1.4.
!>
!>       JAN 2013 - K.C.KORNELSEN
!>                - INCORPORATED LOCATION FLAG FOR INCREASING PRECISION
!>                - OF STREAMFLOW AND RESERVOIR INPUTS
!>                - INCLUDED NSE AND NEGATIVE NSE AS OBJFN'S
!>       JAN 2014 - M. MACDONALD.  INCORPORATED BLOWING SNOW ALGORITHMS
!>       AUG 2013 - M. MACDONALD
!>                - INCORPORATE OPTIONAL COUPLING OF CLASS WITH CTEM
!>                - MOVE SOME INITIALIZATION AND SCATTER OF CLASS
!>                  DIAGNOSTIC VARIABLES IN TO MESH_DRIVER
!>       JUN 2010 - F. SEGLENIEKS. 
!>                - ADDED CODE TO HAVE MESH ONLY RUN ON BASINS LISTED IN 
!>                  THE STREAMFLOW FILE, CALLED THE SUBBASIN FEATURE
!>       JUN 2010 - M.A.MEKONNEN/B.DAVIDSON/M.MacDONALD. 
!>                - BUG FIX FOR READING FORCING DATA IN CSV FORMAT 
!>                  WITH 1 HOUR INTERVAL
!>                - READING FORCING DATA WITH VARIOUS TIME STEPS
!>                - FORCING DATA INTERPOLATION TO 30 MINUTE INTERVALS
!>                  (CLASS MODEL TIME STEP)
!>                - PRE-EMPTION OPTION FOR AUTOCALIBRATION
!>                - CHECKING FOR PARAMETER MINIMUM AND MAXIMUM LIMITS
!>                - PATH SPECIFICATION THAT WORKS FOR BOTH WINDOWS AND 
!>                  UNIX SYSTEMS
!>
!>       AUG 2009 - B.DAVISON. CHANGES TO UPDATE TO SA_MESH 1.3
!>       APL 2009 - CLEAN COMMENTS AND REFINE STRUCTURE AFTER CODE REVIEW
!>       FEB 2009 - MESH12-01 BUG FIX AND ADDING NEW FEATURES
!>       AUG 28/07 - F.SEGLENIEKS. CHANGED FILENAMES AND REARRANGED THE CODE
!>       MAY 21/07 - B.DAVISON.    INITIAL VERSION BASED ON WORK OF E.D. SOULIS
!>       AND F. SEGLENIEKS AT THE UNIVERSITY OF WATERLOO
!>
!>=======================================================================
!>       DIMENSION STATEMENTS.
!>
!>       FIRST SET OF DEFINITIONS:
!>       BACKGROUND VARIABLES, AND PROGNOSTIC AND DIAGNOSTIC
!>       VARIABLES NORMALLY PROVIDED BY AND/OR USED BY THE GCM.
!>       THE SUFFIX "ROW" REFERS TO VARIABLES EXISTING ON THE
!>       MOSAIC GRID ON THE CURRENT LATITUDE CIRCLE.  THE SUFFIX
!>       "GAT" REFERS TO THE SAME VARIABLES AFTER THEY HAVE UNDERGONE
!>       A "GATHER" OPERATION IN WHICH THE TWO MOSAIC DIMENSIONS
!>       ARE COLLAPSED INTO ONE.  THE SUFFIX "GRD" REFERS BOTH TO
!>       GRID-CONSTANT INPUT VARIABLES. AND TO GRID-AVERAGED
!>       DIAGNOSTIC VARIABLES.
!>
!>       THE FIRST DIMENSION ELEMENT OF THE "ROW" VARIABLES
!>       REFERS TO THE NUMBER OF GRID CELLS ON THE CURRENT
!>       LATITUDE CIRCLE.  IN THIS STAND-ALONE VERSION, THIS
!>       NUMBER IS ARBITRARILY SET TO THREE, TO ALLOW UP TO THREE
!>       SIMULTANEOUS TESTS TO BE RUN.  THE SECOND DIMENSION
!>       ELEMENT OF THE "ROW" VARIABLES REFERS TO THE MAXIMUM
!>       NUMBER OF TILES IN THE MOSAIC.  IN THIS STAND-ALONE
!>       VERSION, THIS NUMBER IS SET TO EIGHT.  THE FIRST
!>       DIMENSION ELEMENT IN THE "GAT" VARIABLES IS GIVEN BY
!>       THE PRODUCT OF THE FIRST TWO DIMENSION ELEMENTS IN THE
!>       "ROW" VARIABLES.

!> Note, the internal comments are to be organised with 
!> the following symbols:
!>  -the symbols "!>" at the beginning of the line means that the 
!>  following comments are descriptive documentation.
!>  -the symbols "!*" means that the following comment is a variable
!>  definition.
!>  -the symbols "!+" means that the following comment contains code 
!>  that may be useful in the future and should not be deleted.
!>  -the symbols "!-" means that the following comment contains code
!>  that is basically garbage, and can be deleted safely at any time.
!>  -the symbol "!" or any number of exclamation marks can be used
!>  by the developers for various temporary code commenting.
!>  -the symbol "!todo" refers to places where the developers would 
!>  like to work on.
!>  -the symbol "!futuredo" refers to places where the developers
!>  would like to work on with a low priority.
! =========================================================================
!  
! modified by : Ala Bahrami
! I have applied these modification as a part of my Ph.D thesis in order to implement  
! The MESH Data Assimilation(MESH_DA) structure. 
! 
! Bahrami, 21/03/2017 - Adding using land_force_perturb, forcepert_types, file_variables modules 
!					  - Adding local variables tt, N_t, n2 
!					  - Adding three forcing data perturbation fields precip_pert, sw_pert, lw_pert
!					  - Adding reading input variables of the Input2.ini file 
!					  - Adding ensemble loop 
!					  - Adding the section of Initialize random_fields variables  
!					  - Adding the section of generate random fields for initialization
!					  - Adding the section of assigning variables related to perturbation fields 
!					  - Adding the section of perturbing input forcing data for every time step 
!						   by considering the spatial-temporal and cross correlation. 
!					  - Modifying the gridded data variables for output 
!					  - Adding closure of opened-forcing data for every ensemble loop
!		   03/05/2017 - Deallocate all variables which were been allocated before
!		   11/08/2017 - Adding perturbaiton of model states (SNO, THLQ)	
!		  
! 		   09/01/2018 - Reading and writing the resume files in different folders for each ensemble member 
!		   12/01/2018 -	Allocate data assimilation variable 
!					  -	
!		  
!		   18/01/2018 -
!					  - Storing the random_fields variables at the beginning of the month
!					  
!		   
!		   18/04/2018 -
!					  - Modifying the code to update ic%start%jday when the OL code runs for the 
!					  - the next month in order to read the appropriate input forcing.  	
!					  - Adding a condition to update ic%start%jday and ic%start%year when 
!					  - ic%start%jday exceeds 366 or 367.   
!         26/09/2018  -
!					  - Constraining the perturbation of longwave and shortwave radiation # 1075 to # 1083 
!				
!	
!		   11/10/2018 - 
!					  - changed # 1140 : using one tile vector for perturbations to obseve whether 
!					  - I can observe the bias in April 	
!
! Todo : read the ensemble vector then  perturb input forcing using this vector every time step 
!			
!		  14/10/2018  -
!					  - commnet these lines to speed the running (1053 : 1061) (1068 : 1072) (1082:1085)
!					  - added the variable pert_vector and read it 
!
!		  04/01/2019  -				
!					  - Apply perturbation of precipitation 
!					  - read and write resume of the perturbation for one field 		
!
!		  05/02/2019  -	
!					  - Modifying the code to run month by month whenever the year of simulation is changed	
!					  - Writing and reading the start time of run from input_run_start.ini file  	
!
!		  26/02/2019  - Changed the inputs of UpdateFIELDSOUT function in order to get the gridded output by deviding the desired 
!					    field by shd%FRAC 
!
!        Todo : write the modification on Forcepert
!		
!
!		10/05/2019	  -
!					  - reading forcepert file as an input file and removed get_forcepert() calculations		
!					  - modified the code in the offline mode. See the document file for more info
! =========================================================================	 
	use sa_mesh_shared_variables
	
	use FLAGS 
	
	use mpi_flags
    use mpi_shared_variables
    use mpi_module
	
	
	use sa_mesh_run_within_tile
    use sa_mesh_run_within_grid
	use sa_mesh_run_between_grid
	

	use MODEL_OUTPUT
    use model_output_variabletypes
    use climate_forcing
    use model_dates
    use SIMSTATS
    use model_files
	
	
	! Ala Bahrami added this 
	! Random fields 
	use file_variables
	
	
	implicit none 
	
	!* ierr: Diagnostic error/status return from various subroutines.
    integer :: ierr = 0

    integer istop, ierrcode, irecv, itag

    !> Local variables.
    !* NA: Temporary store for the number of grid cells.
    !* NTYPE: Temporary store for the number of GRUs.
    !* NML: Temporary store for the number of active land elements (NA, NTYPE).
    !* NSL: Temporary store for the number of soil layers.
    !* iun: Temporary store for the unit number of a file.
    integer NA, NTYPE, NML, NSL, iun, ik, jk, ignd
    real FRAC

    !> INTEGER CONSTANTS.
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
!-    integer, parameter :: M_C = 5

!todo clean up commets and arrange variables a bit better

    !> FOR ROUTING
!todo: Fix this (e.g., replace M_C with NRVR; move to process_WF_ROUTE).
    !* WF_R1: MANNING'S N FOR RIVER CHANNEL
    !* WF_R2: OPTIMIZED RIVER ROUGHNESS FACTOR
!-    real WF_R1(M_C), WF_R2(M_C)

!> START ENSIM == FOR ENSIM == FOR ENSIM == FOR ENSIM ==
    character(10) wf_landclassname(10)
    integer(kind = 4) wfo_yy, wfo_mm, wfo_dd, wfo_hh, wfo_mi, wfo_ss, &
        wfo_ms, nj, ensim_month, ensim_day
    integer(kind = 4) WFO_SEQ, ENSIM_IOS
    integer(kind = 4) CURREC
!> == ENSIM == ENSIM == ENSIM == ENSIM == ENSIM ==

    !> For reading in the last information in mesh_paramters_hydrology.ini
    character(30) NMTESTFORMAT

    !> CONSTANTS (PARAMETER DEFINITIONS):
    !* M_X: MAXIMUM ALLOWABLE NUMBER OF GRID COLUMNS IN SHD FILE
    !* M_Y: MAXIMUM ALLOWABLE NUMBER OF GRID ROWS IN SHD FILE
    !* M_S: MAXIMUM ALLOWABLE NUMBER OF STREAMFLOW GAUGES
    !* M_R: MAXIMUM ALLOWABLE NUMBER OF RESERVOIRS
    !* M_C: MAXIMUM ALLOWABLE NUMBER OF RIVER CHANNELS
    !* M_G: MAXIMUM ALLOWABLE NUMBER OF GRID OUTPUTS

    !* VERSION: MESH_DRIVER VERSION
    !* RELEASE: PROGRAM RELEASE VERSIONS
    !* VER_OK: IF INPUT FILES ARE CORRECT VERSION FOR PROGRAM
    character(24) :: VERSION = '1037'
    character(8) RELEASE
!-    logical VER_OK

    !* INDEPPAR: NUMBER OF GRU-INDEPENDENT VARIABLES
    !* DEPPAR: NUMBER OF GRU-DEPENDENT VARIABLES
    integer i, j, k, l, m, u
	
	
!-    integer INDEPPAR, DEPPAR

    integer FRAME_NO_NEW

    !> MAM - logical variables to control simulation runs:
    character(100) cstate
    logical :: ENDDATE = .false., ENDDATA = .false.
    integer :: RUNSTATE = 0

    !>  For cacluating the subbasin grids
!+    integer SUBBASINCOUNT
!+    integer, dimension(:), allocatable :: SUBBASIN

    type(ShedGridParams) :: shd
    type(fl_ids) :: fls

    !* printoutwb: Print components of the water balance to the
    !*             console if enabled.
    logical printoutwb

    !* printoutstfl: Print members of the simulation hydrograph to the
    !*               console if enabled.
    logical printoutstfl, printoutqhyd

    !>THESE ARE THTE TYPES DEFINED IN MODEL_OUTPUT.F95 NEED TO WRITE OUTPUT FIELD ACCUMULATED
    !> OR AVERAGE FOR THE WATER BALANCE AND SOME OTHER STATES VARIABLES
!todo: clean-up.
    type(OUT_FLDS) :: VR
    type(dates_model) :: ts
    type(INFO_OUT) :: ifo
    type(CLIM_INFO) :: cm
    type(met_data) :: md_grd
    type(water_balance) :: wb_grd, wb_acc
    type(energy_balance) :: eb_grd, eb_acc
    type(soil_statevars) :: spv_grd, spv_acc
    type(streamflow_hydrograph) :: stfl
    type(reservoir_release) :: rrls
	
	
	! forcing parameter 
	! remove this 
	!type(forcepert_param_type), dimension(:), allocatable :: forcepert_param

	
    !> Basin totals for the run.
    real TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, STG_INI, STG_FIN, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB

    !> End of run states for prognostic variables.
    real, dimension(:, :), allocatable :: tcan, rcan, sncan, gro, zpnd, tpnd, sno, tsno, albs, rhos
    real, dimension(:, :, :), allocatable :: tbar, thlq, thic
    integer, dimension(:), allocatable :: kc
    character cfmt*3, cfmtt*1000

    logical R2COUTPUT
    integer, parameter :: R2CFILEUNITSTART = 500
    integer NR2C, DELTR2C, NR2CFILES, NR2CSTATES, NR2C_R, DELTR2C_R, NR2C_S, DELTR2C_S
    integer, allocatable, dimension(:) :: GRD, GAT, GRDGAT, GRD_R, GAT_R, GRDGAT_R, GRD_S, GAT_S, GRDGAT_S
    character(50), allocatable, dimension(:, :) :: R2C_ATTRIBUTES, R2C_ATTRIBUTES_R, R2C_ATTRIBUTES_S

    !> To use with variable format expressions in writing some output files
    character(500) fl_listMesh

    real startprog, endprog
    integer narg
	
	! Todo : Eliminite these variables 
	! Note : Ala Bahrami : these variables are added to check the problem of 
	! perturbated fields. 
	! 
	! local variables to skip records of forcpert
	integer JDAY_IND_MET1, ISTEP_START1 , nmy1, nhy1, nrs1, Jday_IND21, Jday_IND31
	
		  
	!> Data assimilation variables 
	
	
	
!+    real alpharain
!+    character(50) alphCh

!> ((((((((((((((((((((((((((((((((((
!> Set the acceptable version numbers
!> ))))))))))))))))))))))))))))))))))
!todo: this should be input file dependent,
!because different files will work with different releases
!so, make them local variables inside each read subroutine.
    RELEASE = '1.4'
	
	! ------------------------------------------------------------ 
	! Launching the program 
    call cpu_time(startprog)
	
	! Initialize MPI
	call mpi_init(ierr)
    if (ierr /= mpi_success) then
        print *, 'Failed to initialize MPI.'
        call mpi_abort(mpi_comm_world, ierrcode, ierr)
        print *, 'ierrcode ', ierrcode, 'ierr ', ierr
    end if

	!> Grab number of total processes and current process ID.
    call mpi_comm_size(mpi_comm_world, inp, ierr)
    call mpi_comm_rank(mpi_comm_world, ipid, ierr)
	 

	!> izero is active if the head node is used for booking and lateral flow
    !> processes.
    if (inp > 1) then
        izero = 1
    else
        izero = 0
    end if

    !> Reset verbose flag for worker nodes.
    if (ipid > 0) ro%VERBOSEMODE = 0

	!> Added by Ala Bahrami 
	!> ------------------------------------------------------------
	!> Reading the input_file random_fields   
	!> ------------------------------------------------------------
	!>> Todo: I should implement this part inside the MESH as function Assim_Param_pert()
	!>> Adding the naming and file unit. See Module files and module_files_variables  
	iun = 960
	open (iun, file = 'Inputs/Assimilation_parameters_perturbation_ol.ini')
		read (iun , *) N_forcepert
 		read (iun , *) N_ens
  	close (iun)
		
	allocate(Forcepert_read(N_forcepert * N_ens))
	allocate(Forcepert_vec(N_forcepert , N_ens))
		
	
	it_counter    = 1
	month_counter = 1
	
	
400 continue 	
	
	
	!> Added by Ala Bahrami 
	!> ------------------------------------------------------------
	!> Starting main ensemble loop   
	!> ------------------------------------------------------------
	
	if (it_counter .eq. 1) then 
	
		write (*,*) ''
		write (*,*) 'The Open_Loop (Forecast) Mode is Active '
		write (*,*) ''
	
	end if 
	
	
do tt = 1 , N_ens
    
	
	!>> Todo : Check the condition of the program for the second run for each ensemble to update model states 
	
	!TODO: UPDATE THIS (RELEASE(*)) WITH VERSION CHANGE
		if (ro%VERBOSEMODE > 0) print 951, trim(RELEASE), trim(VERSION)

	951 format(1x, 'MESH ', a, ' ---  (', a, ')', /)
	
		write (*, '(a)') ''
		write (*, "('Ensemble Member Number = ', i5)") tt
		write (*, '(a)') ''		
		
		!> Check if any command line arguments are found.
		narg = command_argument_count()
		!print *, narg
		if (narg > 0) then

			!> File handled for variable in/out names
			!> At the moment only class, hydro parameters and some outputs
			VARIABLEFILESFLAG = 1
			if (narg >= 1) then
				call get_command_argument(1, fl_listMesh)
	!            print *, fl_listMesh
	!        else if (narg == 2) then
	!            call get_command_argument(1, fl_listMesh)
	!            print *, fl_listMesh
	!todo: re-instate alpha
	!            call get_command_argument(2, alphCh)
	!            call value(alphCh, alpharain, ierr)
	!            cm%dat(8)%alpha = alpha
	!            print *, cm%dat(8)%alpha
			end if
			call Init_fls(fls, trim(adjustl(fl_listMesh)))
		else
		
		
		! ------------------------------------------------------------ 
		! Getting the input file information including its name and index 
			! module_files 
			call Init_fls(fls) 
		 
			!> Added by Ala Bahrami 
			!> ------------------------------------------------------------
			!> Changing location of the input resume file 
			!> ------------------------------------------------------------
			write(strens , '(I5)') , tt
			
			fls%fl(mfk%f883)%fn = 'resume_ens/' // 'forecast/' // 'ens' // trim(adjustl(strens)) // '/'//fls%fl(mfk%f883)%fn
			
		 
		end if  
		
		call READ_INITIAL_INPUTS (shd, &
								  ts, cm, &
								  fls)
		
		!> Added by Ala Bahrami on 04/02/2019
		!> ------------------------------------------------------------
		!> Updating start time of input_run_options.ini date after one month simulation
		!> ------------------------------------------------------------
		if (month_counter .gt. 1) then 
					iun = 920
						open  (iun, file = 'Inputs/input_run_start.ini')
						read (iun , *) 
						read (iun , *)
						read (iun , '(4i4)') ic%start%year, ic%start%jday, ic%start%hour, ic%start%mins
					close(iun)
		end if
		
			
		!> Added by Ala Bahrami 
		!> ------------------------------------------------------------
		!> Opening forcepert input file    
		!> ------------------------------------------------------------	
		iun_per = 963
		open (iun_per, file = 'Inputs/Forcepert.seq', action = 'read', &
					form = 'unformatted', access = 'sequential')
		
		! skipping number of frame should be implemented here same as climte_forcing
		nmy1 = ic%start%mins - cm%dat(1)%start_date%mins
        nhy1 = ic%start%hour - cm%dat(1)%start_date%hour
		
		ISTEP_START1 = 2*24*60/cm%dat(1)%hf
		
		call Julian_Day_ID(ic%start%year, ic%start%jday, Jday_IND21)
        call Julian_Day_ID(cm%dat(1)%start_date%year, cm%dat(1)%start_date%jday, Jday_IND31)
		
		JDAY_IND_MET1 = Jday_IND21 - Jday_IND31
        nrs1 = JDAY_IND_MET1*ISTEP_START1 + nhy1*ISTEP_START1/24 + nmy1/30 - 12
		
		write(*,*) 'numbers of skipped forcepert recoreds',nrs1

		if (nrs1 .gt. 0) then
					do i = 1, nrs1
							read(iun_per), Forcepert_read
					end do
		end if
		
		! ------------------------------------------------------------
		
		call GET_DATES(ts)	
		
		! ------------------------------------------------------------ 
		!Assign shed values to local variables.
		NA = shd%NA
		NTYPE = shd%lc%NTYPE
		NSL = shd%lc%IGND
		
		! ------------------------------------------------------------ 
		!> Initialize output fields.
		! See the model_output.f90
		
		call init_water_balance(wb_grd, shd)
		call init_energy_balance(eb_grd, shd)
		call init_soil_statevars(spv_grd, shd)
		
		! ------------------------------------------------------------ 
		!> Calculate the grid and basin fractional areas.
		wb_grd%grid_area = 0.0
		wb_grd%basin_area = 0.0
		do i = 1, NA
			do m = 1, NTYPE
				wb_grd%grid_area(i) = wb_grd%grid_area(i) + shd%lc%ACLASS(i, m)*shd%FRAC(i)
			end do
			wb_grd%basin_area = wb_grd%basin_area + wb_grd%grid_area(i)
		end do

		
		if (ipid == 0) then

			!> Hourly output.
			call init_met_data(md_grd, shd)

			!> Daily average grid values.
			call init_energy_balance(eb_acc, shd)
			call init_soil_statevars(spv_acc, shd)
			call init_water_balance(wb_acc, shd)

			!> Basin totals for the run.
			TOTAL_PRE = 0.0
			TOTAL_EVAP = 0.0
			TOTAL_ROF = 0.0
			TOTAL_ROFO = 0.0
			TOTAL_ROFS = 0.0
			TOTAL_ROFB = 0.0

		end if !(ipid == 0) then
		
		! ------------------------------------------------------------ 

		call run_within_tile_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
		
		
		call run_within_grid_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
	 
		! ------------------------------------------------------------ 
		!> MAM - Check for parameter values - all parameters should lie within the
		!> specified ranges in the "minmax_parameters.txt" file.

		call check_parameters(shd)
		

1114 	  format(/1x, 'Error allocating ', a, ' variables.', & 
				 /1x, 'Check that these bounds are within an acceptable range.', /)
1118 	  format(3x, a, ': ', i6)

		!>  For cacluating the subbasin grids
	!+    allocate(SUBBASIN(NML), stat = ierr)
	!+    if (ierr /= 0) then
	!+        print 1114, 'subbasin grid'
	!+        print 1118, 'Grid squares', NA
	!+        print 1118, 'GRUs', NTYPE
	!+        print 1118, 'Total tile elements', NML
	!+        stop
	!+    end if

		if (ipid == 0) call run_between_grid_init(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
		
		 
		
		! See : SA_RTE_module (print : Standalone Routing is activated)
		! See : WF_ROUTE_config (STREAMFLOW GUAGES and RESERVOIR)  
		
		! ------------------------------------------------------------ 
		ENDDATA = climate_module_init(fls, shd, il1, il2, cm)
		
		! See: Climate_forcing_module  and open_data in climate_forcing_module_io
		!(print information in console such as name of forcing, number of days (nrs) )
		
		
		if (ENDDATA) then
			RUNSTATE = 1
			goto 997
		end if
		
		

		! ------------------------------------------------------------ 
		!> Initialize output fields.
		if (ipid == 0) then
			if (OUTFIELDSFLAG == 1) call init_out(shd, ts, ifo, vr)
		end if !(ipid == 0) then

		FRAME_NO_NEW = 1

		! ------------------------------------------------------------ 
		!> Determine what output will print to the console.
		printoutwb = (allocated(wb_acc%pre) .and. allocated(wb_acc%evap) .and. allocated(wb_acc%rof))
		printoutstfl = allocated(stfl%qsyn)
		printoutqhyd = (allocated(stfl%qhyd) .and. allocated(stfl%qsyn))

		if (ipid == 0) then

		!> ******************************************************
		!> echo print information to MESH_output_echo_print.txt
		!> ******************************************************

			if (MODELINFOOUTFLAG > 0) then
				write(58, "('Number of Soil Layers (IGND) = ', i5)") NSL
				write(58, *)
				write(58, "('MESH_input_run_options.ini')")
				write(58, *)
				write(58, "('Configuration flags - specified by user or default values')")

	!todo: this list should be updated (dgp: 2015-01-09)
				write(58, *) 'BASINSHORTWAVEFLAG   = ', cm%dat(ck%FB)%ffmt
				write(58, *) 'BASINLONGWAVEFLAG    = ', cm%dat(ck%FI)%ffmt
				write(58, *) 'BASINRAINFLAG        = ', cm%dat(ck%RT)%ffmt
				write(58, *) 'BASINTEMPERATUREFLAG = ', cm%dat(ck%TT)%ffmt
				write(58, *) 'BASINWINDFLAG        = ', cm%dat(ck%UV)%ffmt
				write(58, *) 'BASINPRESFLAG        = ', cm%dat(ck%P0)%ffmt
				write(58, *) 'BASINHUMIDITYFLAG    = ', cm%dat(ck%HU)%ffmt
	!-            write(58, *) 'HOURLYFLAG           = ', HOURLYFLAG
				write(58, *) 'RESUMEFLAG           = ', RESUMEFLAG
				write(58, *) 'SAVERESUMEFLAG       = ', SAVERESUMEFLAG
				write(58, *) 'SHDFILEFLAG          = ', SHDFILEFLAG
				write(58, *) 'SOILINIFLAG          = ', SOILINIFLAG
				write(58, *) 'PREEMPTIONFLAG       = ', mtsflg%PREEMPTIONFLAG
	!-            write(58, *) 'INTERPOLATIONFLAG    = ', INTERPOLATIONFLAG
				write(58, *) 'SUBBASINFLAG         = ', SUBBASINFLAG
				write(58, *) 'R2COUTPUTFLAG        = ', R2COUTPUTFLAG
				write(58, *) 'OBJFNFLAG            = ', OBJFNFLAG
				write(58, *) 'AUTOCALIBRATIONFLAG  = ', mtsflg%AUTOCALIBRATIONFLAG
				write(58, *) 'WINDOWSIZEFLAG       = ', WINDOWSIZEFLAG
				write(58, *) 'WINDOWSPACINGFLAG    = ', WINDOWSPACINGFLAG
				write(58, *) 'FROZENSOILINFILFLAG  = ', FROZENSOILINFILFLAG
				write(58, *) 'LOCATIONFLAG         = ', LOCATIONFLAG

	!todo: restore this.
	!+            write(58, "('WF_NUM_POINTS: ', i5)") WF_NUM_POINTS
	!+            write(58, "('Out directory:', 5a10)") (op%DIR_OUT(i), i = 1, WF_NUM_POINTS)
	!+            write(58, "('Grid number:  ', 5i10)") (op%N_OUT(i), i = 1, WF_NUM_POINTS)
	!+            write(58, "('Land class:   ', 5i10)") (op%II_OUT(i), i = 1, WF_NUM_POINTS)
	!            write(58, *)
	!            write(58, "('MESH_parameters_hydrology.ini')")
	!            write(58, *)
	!todo: fix this.
	!-            write(58, "('Option flags:')")
	!-            if (OPTFLAGS > 0) then
	!-                do i = 1, OPTFLAGS
	!-                    write(58, '(a11, i2, a19)') 'PARAMETER ', i, ' NOT CURRENTLY USED'
	!-                end do
	!-            end if
	!            write(58, "('River roughnesses:')")
	!todo: change this to use NRVR.
			end if !(MODELINFOOUTFLAG > 0) then
		end if !(ipid == 0) then

	if (ipid == 0) then
			NR2CFILES = 0
			if (R2COUTPUTFLAG >= 1) then
				inquire(file = 'r2c_output.txt', exist = R2COUTPUT)
				if (R2COUTPUT) then
					open(56, file = 'r2c_output.txt', action = 'read')
					read(56, *, iostat = ierr) NR2C, DELTR2C
					if (ierr == 0) then
						allocate(GRD(NR2C), GAT(NR2C), GRDGAT(NR2C), R2C_ATTRIBUTES(NR2C, 3), stat = ierr)
						if (ierr /= 0) then
							print *, 'ALLOCATION ERROR: CHECK THE VALUE OF THE FIRST ', &
								'RECORD AT THE FIRST LINE IN THE r2c_output.txt FILE. ', &
								'IT SHOULD BE AN INTEGER VALUE (GREATER THAN 0).'
							stop
						end if
					end if
					if (ierr /= 0 .or. mod(DELTR2C, 30) /= 0) then
						print 9002
						stop
					end if
					print *
					print *, 'THE FOLLOWING R2C OUTPUT FILES WILL BE WRITTEN:'
					do i = 1, NR2C
						read(56, *, iostat = ierr) GRD(i), GAT(i), GRDGAT(i), (R2C_ATTRIBUTES(i, j), j = 1, 3)
						if (ierr /= 0) then
							print *, 'ERROR READING r2c_output.txt FILE AT LINE ', i + 1
							stop
						else
							if (GRD(i) == 1) then
								NR2CFILES = NR2CFILES + 1
								print *, NR2CFILES, ' (GRD)    : ', R2C_ATTRIBUTES(i, 3)
							end if
							if (GAT(i) == 1) then
								NR2CFILES = NR2CFILES + 1
								print *, NR2CFILES, ' (GAT)    : ', R2C_ATTRIBUTES(i, 3)
							end if
							if (GRDGAT(i) == 1) then
								NR2CFILES = NR2CFILES + 1
								print *, NR2CFILES, ' (GRDGAT) : ', R2C_ATTRIBUTES(i, 3)
							end if
						end if
					end do
					close(56)
				else
					print *
					print *, "r2c_output.txt FILE DOESN'T EXIST. ", &
						'R2COUTPUTFLAG SHOULD BE SET TO ZERO IF R2C OUTPUTS ARE NOT NEEDED.'
					print *
					stop
				end if
			end if

			!> WRITE THE HEADER FOR R2C FILES:
			if (NR2CFILES > 0) then
				call WRITE_R2C_HEADER(NTYPE, NR2C, NR2CFILES, GRD, GAT, GRDGAT, R2C_ATTRIBUTES, &
									  R2CFILEUNITSTART, NR2CSTATES, shd%CoordSys%Proj, shd%CoordSys%Ellips, shd%CoordSys%Zone, &
									  shd%xOrigin, shd%yOrigin, shd%xDelta, shd%yDelta, shd%xCount, shd%yCount)
			end if

			!> For the ENSIM timestamp
			wfo_seq = 0

		end if !(ipid == 0) then

		!> *********************************************************************
		!> Output diagnostic information to screen.
		!> *********************************************************************

		if (ro%VERBOSEMODE > 0) then
			print *, 'NUMBER OF GRID SQUARES: ', NA
			print *, 'NUMBER OF LAND CLASSES (WITH IMPERVIOUS): ', NTYPE
			print *, 'NUMBER OF RIVER CLASSES: ', shd%NRVR
			print *, 'MINIMUM NUMBER FOR ILG: ', shd%lc%ILG
			print *, 'NUMBER OF GRID SQUARES IN West-East DIRECTION: ', shd%xCount
			print *, 'NUMBER OF GRID SQUARES IN South-North DIRECTION: ', shd%yCount
			print *, 'LENGTH OF SIDE OF GRID SQUARE IN M: ', shd%AL
			print *, 'NUMBER OF DRAINAGE OUTLETS: ', (NA - shd%NAA)
			print *
			print *
			print *
		end if !(ro%VERBOSEMODE > 0) then

		!> RESUME/SAVERESUME 1 or 2 are not supported.
		if (ipid == 0) then
			if (RESUMEFLAG == 1 .or. SAVERESUMEFLAG == 1 .or. RESUMEFLAG == 2 .or. SAVERESUMEFLAG == 2) then
				print 679, RESUMEFLAG, SAVERESUMEFLAG
				stop
			end if
		end if

679     	format(/ &
				   /1x, 'RESUMEFLAG ', i1, ' and SAVERESUMEFLAG ', i1, ' are not supported.', &
				   /1x, 'Use RESUMEFLAG 4 or SAVERESUMEFLAG 4 instead.', &
				   /1x, 'Individual variables for RESUME/SAVERESUME or the file format', &
				   /1x, 'of the resume files cannot be configured at this time.')

	!> ********************************************************************
		! ------------------------------------------------------------ 
		!> Initialize accumulation variables.
		if (ipid == 0) then

			!> Initialize accumulation variables.
			wb_acc%PRE = 0.0
			eb_acc%QEVP = 0.0
			wb_acc%EVAP = 0.0
			eb_acc%HFS = 0.0
			wb_acc%ROF = 0.0
			wb_acc%ROFO = 0.0
			wb_acc%ROFS = 0.0
			wb_acc%ROFB = 0.0
			spv_acc%TBAR = 0.0
			spv_acc%THLQ = 0.0
			wb_acc%LQWS = 0.0
			spv_acc%THIC = 0.0
			wb_acc%FRWS = 0.0
			eb_acc%GFLX = 0.0
			wb_acc%RCAN = 0.0
			wb_acc%SNCAN = 0.0
			wb_acc%SNO = 0.0
			wb_acc%WSNO = 0.0
			wb_acc%PNDW = 0.0
			wb_acc%STG = 0.0
			wb_acc%DSTG = 0.0

		end if !(ipid == 0) then
		
		! ------------------------------------------------------------ 
		!> Calculate initial storage.
		if (ipid == 0) then
			STG_INI = sum(wb_grd%stg)/wb_grd%basin_area
		end if !(ipid == 0) then
		
		! ------------------------------------------------------------ 
		!> Read in existing basin states for RESUMEFLAG.
		if (RESUMEFLAG == 4) then

			!> Open the resume file for the driver.
			iun = fls%fl(mfk%f883)%iun
			open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'old', action = 'read', &
				 form = 'unformatted', access = 'sequential', iostat = ierr)
	!todo: condition for ierr.

			!> Time-stepping information.
			read(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
			read(iun) ic%count_year, ic%count_jday, ic%count_month, ic%count_jday, ic%count_hour, ic%count_mins
			read(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count
			
			!> Read states for the driver (for the head node or in serial).
			if (ipid == 0) then

				!> Water balance totals.
				read(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
				
				read(iun) STG_INI
				
				!> Daily streamflow values.
				read(iun) stfl%qhyd
				read(iun) stfl%qsyn

			end if

			!> Close the file to free the unit.
			close(iun)

		end if !(RESUMEFLAG == 4) then
		
		if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_init(fls, stfl)

		!> ------------------------------------------------------------
		!> End of Initialization
		!> ------------------------------------------------------------

		if (ro%VERBOSEMODE > 0) then
			print *
			print 2836
			print 2835
		end if !(ro%VERBOSEMODE > 0) then

2836    	format(/1x, 'DONE INTITIALIZATION')
2835    	format(/1x, 'STARTING MESH')

		
		!> Addded by Ala Bahrami
		!> ------------------------------------------------------------
		!> Assigning variable related to perturbation fields   
		!> ------------------------------------------------------------
		
		NML = shd%lc%NML
		
		! deallocate variables for reading forcepert 
		!if(allocated(Forcepert_read)) deallocate(Forcepert_read)
		!if(allocated(Forcepert_vec)) deallocate(Forcepert_vec)
		 
		
		!>------------------------------------------------------------
		!> Start of main loop that is run each half hour
		!> ------------------------------------------------------------
		
		
		! reset the valeus 
		
		ENDDATE = .false. 
		RUNSTATE = 0
		 
		N_t = 0
		
		do while (.not. ENDDATE .and. .not. ENDDATA )
		!do while ( .not. ENDDATA )
		
			!> Pass the run state from the head to worker nodes.
	!+        if (inp > 1 .and. ipid /= 0) then

				!> Receive data from the head node.
	!+            call MPI_Recv(RUNSTATE, 1, MPI_INT, 0, ipid, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)
	!+        else if (inp > 1) then

				!> Send data for the worker nodes.
	!+            do u = 1, (inp - 1)
	!+                call MPI_Send(RUNSTATE, 1, MPI_INT, u, u, MPI_COMM_WORLD, ierr)
	!+            end do
	!+        end if !(inp > 1 .and. ipid /= 0) then

	!-        if (inp > 1 .and. ic%ts_daily == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

			if (RUNSTATE /= 0) exit

			N_t = N_t + 1 
			
			
			ENDDATA = climate_module_update_data(fls, shd, il1, il2, cm)
								
				
			!> Addded by Ala Bahrami
			!> ------------------------------------------------------------
			!> Reading input forcepert at each time step
			!> ------------------------------------------------------------	 
			read(iun_per), Forcepert_read  	
			Forcepert_vec = reshape(Forcepert_read,(/N_forcepert, N_ens/))	
			
			!-------------------------------------------------------------			
			! Convert from the Gridded value to GRU 
			do k = 1, NML
						   !>> Todo1 : Consider the cross correlation between different soil moisture layers
						   ! See Kumar article for more info
						   
						   !>> Todo2 : set up a condition to perturb model states based on temperature. 
						   ! See Forman et al. 2012 for more info
						   
						   ! forcing data perturbation fields 
						   !-------------------------------------------------------------
						   ! precip_pert(k, 1)      = Forcepert_vect(1, (shd%lc%ILMOS(k)) , tt)
						   ! sw_pert(k, 1) 	        = Forcepert_vect(2, (shd%lc%ILMOS(k)) , tt)
						   ! lw_pert(k, 1)          = Forcepert_vect(3, (shd%lc%ILMOS(k)) , tt)
						   ! swe_pert(k, 1) 	    = Forcepert_vect(4, (shd%lc%ILMOS(k)) , tt)
						   
						   ! thlq_pert(k, 1)	    = Forcepert_vect(5, (shd%lc%ILMOS(k)) , tt)
						   ! thic_pert(k, 1)	    = Forcepert_vect(6, (shd%lc%ILMOS(k)) , tt)
						   
						   ! thlq_pert(k, 2)	    = Forcepert_vect(7, (shd%lc%ILMOS(k)) , tt)
						   ! thic_pert(k, 2)	    = Forcepert_vect(8, (shd%lc%ILMOS(k)) , tt)
						
						   ! thlq_pert(k, 3)	    = Forcepert_vect(9, (shd%lc%ILMOS(k)) , tt)
						   ! thic_pert(k, 3)	    = Forcepert_vect(10, (shd%lc%ILMOS(k)) , tt)	
						   
						   ! thlq_pert(k, 4)	    = Forcepert_vect(11, (shd%lc%ILMOS(k)) , tt)
						   ! thic_pert(k, 4)	    = Forcepert_vect(12, (shd%lc%ILMOS(k)) , tt)	
						   !-------------------------------------------------------------
						   ! cm%dat(3)%GAT(k) 	= cm%dat(3)%GAT(k) * precip_pert(k, 1)
						   ! cm%dat(1)%GAT(k) 	= cm%dat(1)%GAT(k) * sw_pert(k, 1)
						   ! cm%dat(2)%GAT(k) 	= cm%dat(2)%GAT(k) + lw_pert(k, 1) 
						   
						   cm%dat(3)%GAT(k) 	= cm%dat(3)%GAT(k) * Forcepert_vec(1,tt)
						   cm%dat(1)%GAT(k) 	= cm%dat(1)%GAT(k) * Forcepert_vec(2,tt)
						   cm%dat(2)%GAT(k) 	= cm%dat(2)%GAT(k) + Forcepert_vec(3,tt)
						   stas%sno%sno(k)		= stas%sno%sno(k)  * Forcepert_vec(4,tt)
						   
						   !-------------------------------------------------------------
						   ! constrain perturbed longwave radiation
						   if (cm%dat(2)%GAT(k) .lt. 100) then 
								cm%dat(2)%GAT(k) = 100
						   end if

						   ! constrain perturbed shortwave radiation
						   if (cm%dat(1)%GAT(k) .gt. 1110) then 
								cm%dat(1)%GAT(k) = 1110
						   end if	
						   !-------------------------------------------------------------
						   
						   ! if (ic%ts_daily == 48 .and. k .eq. 7) then 
									! write (*,*) 'thlq_pert(k, 1,2)' , thlq_pert(k, 1), thlq_pert(k, 2) 
						   ! end if 
						   
						   
						   ! ! perturbing model states 
						   !stas%sno%sno(k)			= stas%sno%sno(k)    * swe_pert(k, 1)
						    
						   !if (stas%sno%sno(k).eq.0 .and. stas%sl%tbar(k, 1).gt. 273.16 ) then
									!if (abs(thlq_pert(k, 1)).le. 0.07) then
										! layer 1
										! stas%sl%thlq(k, 1)		= stas%sl%thlq(k, 1) + thlq_pert(k, 1)  
										! stas%sl%thic(k, 1)		= stas%sl%thic(k, 1) + thic_pert(k, 1)  
										
										! stas%sl%thlq(k, 2)		= stas%sl%thlq(k, 2) + thlq_pert(k, 2)  
										! stas%sl%thic(k, 2)		= stas%sl%thic(k, 2) + thic_pert(k, 2)  
										
										! stas%sl%thlq(k, 3)		= stas%sl%thlq(k, 3) + thlq_pert(k, 3)  
										! stas%sl%thic(k, 3)		= stas%sl%thic(k, 3) + thic_pert(k, 3)
										
										! stas%sl%thlq(k, 4)		= stas%sl%thlq(k, 4) + thlq_pert(k, 4)  
										! stas%sl%thic(k, 4)		= stas%sl%thic(k, 4) + thic_pert(k, 4)
										
									!end if 
									
						   !end if 
						   
						   ! if (stas%sno%sno(k).eq.0 .and. stas%sl%tbar(k, 2).gt. 273.16 ) then
									! !if (abs(thlq_pert(k, 1)).le. 0.07) then
										! stas%sl%thlq(k, 2)		= stas%sl%thlq(k, 2) + thlq_pert(k, 2) 
										
									! !end if 
									
						   ! end if 
						   
						   
			end do
			
			! ! end of perturbation for every time step (30 min) 
			! ------------------------------------------------------------
			
				
			if (ENDDATA) then
				RUNSTATE = 1
			   cycle
			end if

			
			!> Reset variables that accumulate on the daily time-step.
			if (ipid == 0 .and. ic%ts_daily == 1) then
				wb_acc%PRE = 0.0
				eb_acc%QEVP = 0.0
				wb_acc%EVAP = 0.0
				eb_acc%HFS = 0.0
				wb_acc%ROF = 0.0
				wb_acc%ROFO = 0.0
				wb_acc%ROFS =  0.0
				wb_acc%ROFB = 0.0
				spv_acc%TBAR = 0.0
				spv_acc%THLQ = 0.0
				wb_acc%LQWS = 0.0
				spv_acc%THIC = 0.0
				wb_acc%FRWS = 0.0
				eb_acc%GFLX = 0.0
				wb_acc%RCAN = 0.0
				wb_acc%SNCAN = 0.0
				wb_acc%SNO = 0.0
				wb_acc%WSNO = 0.0
				wb_acc%PNDW = 0.0
			end if

			!> Reset variables.
			if (ipid == 0) then
				wb_grd%PRE = 0.0
				eb_grd%QEVP = 0.0
				wb_grd%EVAP = 0.0
				wb_grd%pevp = 0.0
				wb_grd%evpb = 0.0
				eb_grd%HFS = 0.0
				wb_grd%ROF = 0.0
				wb_grd%ROFO = 0.0
				wb_grd%ROFS =  0.0
				wb_grd%ROFB = 0.0
				spv_grd%TBAR = 0.0 
				spv_grd%THLQ = 0.0
				wb_grd%LQWS = 0.0
				spv_grd%THIC = 0.0
				wb_grd%FRWS = 0.0
				eb_grd%GFLX = 0.0
				wb_grd%RCAN = 0.0
				wb_grd%SNCAN = 0.0
				wb_grd%SNO = 0.0
				wb_grd%WSNO = 0.0
				wb_grd%PNDW = 0.0
				wb_grd%DSTG = wb_grd%STG
				wb_grd%STG = 0.0
			end if

			! Two main functions. Most of MESH calculations are obtianed according to 
			!  run_within_tile and run_within_grid.  
			! See also: counter and read climate 
			
			
			
			
			cstate = run_within_tile(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
			 
						
			if (len_trim(cstate) > 0) then
				RUNSTATE = 1
				cycle
			end if
			
			
			call run_within_grid(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
			
			
			!> *********************************************************************
			!> Start of book-keeping and grid accumulation.
			!> *********************************************************************

			if (ipid == 0) then

				!> Write ENSIM output
				if (NR2CFILES > 0 .and. mod(ic%ts_daily*30, DELTR2C) == 0) then
				! commend line between #line 1135 until #line 1176 are deleted 
					FRAME_NO_NEW = FRAME_NO_NEW + 1 !UPDATE COUNTERS
				end if

				!> CALCULATE GRID CELL AVERAGE DIAGNOSTIC FIELDS.

				!> Grid data for output.
				md_grd%fsdown = cm%dat(ck%FB)%GRD
				md_grd%fsvh = cm%dat(ck%FB)%GRD/2.0
				md_grd%fsih = cm%dat(ck%FB)%GRD/2.0
				md_grd%fdl = cm%dat(ck%FI)%GRD
				md_grd%ul = cm%dat(ck%UV)%GRD
				md_grd%ta = cm%dat(ck%TT)%GRD
				md_grd%qa = cm%dat(ck%HU)%GRD
				md_grd%pres = cm%dat(ck%P0)%GRD
				md_grd%pre = cm%dat(ck%RT)%GRD


				! delete #line 1193 until # 1221 

				wb_grd%DSTG = wb_grd%RCAN + wb_grd%SNCAN + wb_grd%SNO + wb_grd%WSNO + wb_grd%PNDW + &
					sum(wb_grd%LQWS, 2) + sum(wb_grd%FRWS, 2) - wb_grd%STG
				wb_grd%STG = wb_grd%DSTG + wb_grd%STG

								
				!> Update output data.
				if (OUTFIELDSFLAG == 1) call updatefieldsout_temp(shd, ts, ifo, &
																  md_grd, wb_grd, &
																  vr)

				!> Basin totals for the run.
				TOTAL_PRE = TOTAL_PRE + sum(wb_grd%PRE)
				TOTAL_EVAP = TOTAL_EVAP + sum(wb_grd%EVAP)
				TOTAL_ROF = TOTAL_ROF + sum(wb_grd%ROF)
				TOTAL_ROFO = TOTAL_ROFO + sum(wb_grd%ROFO)
				TOTAL_ROFS = TOTAL_ROFS + sum(wb_grd%ROFS)
				TOTAL_ROFB = TOTAL_ROFB + sum(wb_grd%ROFB)

				!> ACCUMULATE OUTPUT DATA FOR DIURNALLY AVERAGED FIELDS.
				wb_acc%PRE = wb_acc%PRE + wb_grd%PRE
				eb_acc%QEVP = eb_acc%QEVP + eb_grd%QEVP
				wb_acc%EVAP = wb_acc%EVAP + wb_grd%EVAP
				eb_acc%HFS  = eb_acc%HFS + eb_grd%HFS
				wb_acc%ROF = wb_acc%ROF + wb_grd%ROF
				wb_acc%ROFO = wb_acc%ROFO + wb_grd%ROFO
				wb_acc%ROFS = wb_acc%ROFS + wb_grd%ROFS
				wb_acc%ROFB = wb_acc%ROFB + wb_grd%ROFB
				spv_acc%TBAR = spv_acc%TBAR + spv_grd%TBAR
				spv_acc%THLQ = spv_acc%THLQ + spv_grd%THLQ
				wb_acc%LQWS = wb_acc%LQWS + wb_grd%LQWS
				spv_acc%THIC = spv_acc%THIC + spv_grd%THIC
				wb_acc%FRWS = wb_acc%FRWS + wb_grd%FRWS
				eb_acc%GFLX = eb_acc%GFLX + eb_grd%GFLX
				wb_acc%RCAN = wb_acc%RCAN + wb_grd%RCAN
				wb_acc%SNCAN = wb_acc%SNCAN + wb_grd%SNCAN
				wb_acc%SNO = wb_acc%SNO + wb_grd%SNO
				wb_acc%WSNO = wb_acc%WSNO + wb_grd%WSNO
				wb_acc%PNDW = wb_acc%PNDW + wb_grd%PNDW
				
				

				!> CALCULATE AND PRINT DAILY AVERAGES.
				if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
											!when they're numbered 1-48

					eb_acc%QEVP = eb_acc%QEVP/real(ic%ts_daily)
					eb_acc%HFS = eb_acc%HFS/real(ic%ts_daily)
					spv_acc%TBAR = spv_acc%TBAR/real(ic%ts_daily)
					spv_acc%THLQ = spv_acc%THLQ/real(ic%ts_daily)
					wb_acc%LQWS = wb_acc%LQWS/real(ic%ts_daily)
					spv_acc%THIC = spv_acc%THIC/real(ic%ts_daily)
					wb_acc%FRWS = wb_acc%FRWS/real(ic%ts_daily)
					eb_acc%GFLX = eb_acc%GFLX/real(ic%ts_daily)
					wb_acc%RCAN = wb_acc%RCAN/real(ic%ts_daily)
					wb_acc%SNCAN = wb_acc%SNCAN/real(ic%ts_daily)
					wb_acc%SNO = wb_acc%SNO/real(ic%ts_daily)
					wb_acc%WSNO = wb_acc%WSNO/real(ic%ts_daily)
					wb_acc%PNDW = wb_acc%PNDW/real(ic%ts_daily)

					!> Calculate storage terms.
					wb_acc%DSTG = wb_grd%DSTG
					wb_acc%STG = wb_grd%STG
					
					
					if (OUTFIELDSFLAG == 1) then
						! See model outputs 
						! call UpdateFIELDSOUT(vr, ts, ifo, &
											 ! wb_acc%pre, wb_acc%evap, wb_acc%rof, wb_acc%dstg, &
											 ! spv_acc%tbar, wb_acc%lqws, wb_acc%frws, &
											 ! wb_acc%rcan, wb_acc%sncan, &
											 ! wb_acc%pndw, wb_acc%sno, wb_acc%wsno, &
											 ! eb_acc%gflx, eb_acc%hfs, eb_acc%qevp, &
											 ! spv_acc%thlq, spv_acc%thic, &
											 ! NSL, &
											 ! ic%now%jday, ic%now%year)
						
						call UpdateFIELDSOUT(vr, ts, ifo, &
                                         wb_acc%pre/shd%FRAC, wb_acc%evap/shd%FRAC, wb_acc%rof/shd%FRAC, wb_acc%dstg, &
                                         spv_acc%tbar, wb_acc%lqws, wb_acc%frws, &
                                         wb_acc%rcan/shd%FRAC, wb_acc%sncan/shd%FRAC, &
                                         wb_acc%pndw/shd%FRAC, wb_acc%sno/shd%FRAC, wb_acc%wsno/shd%FRAC, &
                                         eb_acc%gflx, eb_acc%hfs/shd%FRAC, eb_acc%qevp/shd%FRAC, &
                                         spv_acc%thlq, spv_acc%thic, &
                                         NSL, &
                                         ic%now%jday, ic%now%year)	
						
					end if

				end if !(ic%ts_daily == 48) then

			end if !(ipid == 0) then

			
			if (ipid == 0) call run_between_grid(shd, fls, ts, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
			
		
			if (ipid == 0) then

				!----------------------------------------------------------------------------
				!> Write output to the console.
				if (ic%ts_daily == 48) then !48 is the last half-hour period of the day
											!when they're numbered 1-48

					if (ro%VERBOSEMODE > 0) then
						write(6, '(2i5)', advance = 'no') ic%now%year, ic%now%jday
						if (printoutstfl) then
							do j = 1, stfl%ns
								if (printoutqhyd) write(6, '(f10.3)', advance = 'no') stfl%qhyd(j)
								write(6, '(f10.3)', advance = 'no') stfl%qsyn(j)
							end do
						end if
	!todo: restore this or replace with basin total.
	!                    j = ceiling(real(NA)/2); if (WF_NUM_POINTS > 0) j = op%N_OUT(1)
						j = shd%NAA
						if (printoutwb) write(6, '(3(f10.3))', advance = 'no') wb_acc%pre(j), wb_acc%evap(j), wb_acc%rof(j)
						write(6, *)
					end if !(ro%VERBOSEMODE > 0) then
					if (mtsflg%AUTOCALIBRATIONFLAG > 0) then
						call stats_update_stfl_daily(fls, stfl)
						if (mtsflg%PREEMPTIONFLAG > 1) then
							if (FTEST > FBEST) goto 199
						end if
					end if

				end if !(ic%ts_daily == 48) then
			end if !(ipid == 0) then

	5176    format(2i5, 999(f10.3))
			
			! Added by Ala Bahrami on 04/02/2019
			!> ------------------------------------------------------------
			!> To Limit running of the code more than one month and reset it when it passes one year 
			!> ------------------------------------------------------------
			call Julian2MonthDay((ic%now%jday + 1), ic%now%year, nmth, ndy) 
			
			if (ic%ts_daily == 48) then 
					if (ndy == 1) then
						ENDDATE = .true.
						
					else if  ((leap_year(ic%now%year) == 365) .and. (ic%now%jday == 365)) then
						ENDDATE = .true.
					else if ((leap_year(ic%now%year) == 366) .and. (ic%now%jday == 366)) then
						ENDDATE = .true.
					end if
			end if 		
		
			! ------------------------------------------------------------
			
			!> Update the current time-step and counter.
			call counter_update()

			!> Check if we should terminate the run yet.
			if (ic%now%year >= ic%stop%year .and. ic%stop%year > 0) then
				if (ic%now%year > ic%stop%year) then
					ENDDATE = .true.
				else if (ic%now%year == ic%stop%year .and. ic%now%jday >= ic%stop%jday) then
					if (ic%now%jday > ic%stop%jday) then
						ENDDATE = .true.
					else if (ic%now%jday == ic%stop%jday .and. ic%now%hour >= ic%stop%hour) then
						if (ic%now%hour > ic%stop%hour) then
							ENDDATE = .true.
						else if (ic%now%hour == ic%stop%hour .and. ic%now%mins >= ic%stop%mins) then
							ENDDATE = .true.
						end if
					end if
				end if
			end if

			!> Check the run state.
			if (ENDDATA .or. ENDDATE) then
				RUNSTATE = 1
				exit
			end if
			 
			!> Pass the run state from the worker to head nodes.
	!+        if (inp > 1 .and. ipid /= 0) then

				!> Receive data from the head node.
	!+            call MPI_Send(RUNSTATE, 1, MPI_INT, 0, ipid, MPI_COMM_WORLD, ierr)
	!+        else if (inp > 1) then

				!> Send data for the worker nodes.
	!+            do u = 1, (inp - 1)
	!+                call MPI_Recv(irecv, 1, MPI_INT, u, u, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)
	!+                RUNSTATE = max(RUNSTATE, irecv)
	!+            end do
	!+        end if !(inp > 1 .and. ipid /= 0) then

	!-        if (inp > 1 .and. ic%ts_daily == MPIUSEBARRIER) call MPI_Barrier(MPI_COMM_WORLD, ierr)

		end do !while (.not. ENDDATE .and. .not. ENDDATA)
		
		
		!----------------------------------------------------------------------------
		!>
		!> ENDDATA mark
		!>
		
	997     continue

		!> End program if not the head node.
		if (ipid /= 0) then
			if (ro%DIAGNOSEMODE > 0) print 4696, ipid
			goto 999

	4696    format (1x, 'Node ', i4, ' is exiting...')

		end if !(ipid /= 0) then
		
		
		
		!> ----------------------------------------------------------------------------
		!> SAVERESUMEFLAG
		!> ---------------------------------------------------------------------------- 
		if (OUTFIELDSFLAG == 1) call write_outputs(shd, fls, ts, ifo, vr)

		!> ----------------------------------------------------------------------------
		!> Run is now over, print final results to the screen and close files
		!> ----------------------------------------------------------------------------
		if (ENDDATA) print *, 'Reached end of forcing data'
		if (ENDDATE) print *, 'Reached end of simulation date'
		
		 

	998     continue

		if (len_trim(cstate) > 0) print *, trim(cstate)

	199 continue

		if (ipid == 0 .and. mtsflg%AUTOCALIBRATIONFLAG > 0) call stats_write(fls)

		!> Call finalization routines. 
		
		call run_within_tile_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
		
		call run_within_grid_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
		call climate_module_finalize(fls, shd, cm)

		
		
		if (ipid == 0) then

			!> Call finalization routines.
			call run_between_grid_finalize(fls, shd, cm, wb_grd, eb_grd, spv_grd, stfl, rrls)
			
			
			!> Save the current state of the model for SAVERESUMEFLAG.
			if (SAVERESUMEFLAG == 4) then

				!> Open the resume file for the driver.
				iun = fls%fl(mfk%f883)%iun
				open(iun, file = trim(adjustl(fls%fl(mfk%f883)%fn)) // '.mesh_driver', status = 'replace', action = 'write', &
					 form = 'unformatted', access = 'sequential', iostat = ierr)
	!todo: condition for ierr.

				!> Time-stepping information.
				write(iun) ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
				! write (*,*) 'year, jday, month, day, hour, min', &
				! ic%now%year, ic%now%jday, ic%now%month, ic%now%day, ic%now%hour, ic%now%mins
				
				write(iun) ic%count_year, ic%count_jday, ic%count_month, ic%count_jday, ic%count_hour, ic%count_mins
				! write (*,*) 'count_year, count_jday, count_month, count_day, count_hour, count_min', &
				! ic%count_year, ic%count_jday, ic%count_month, ic%count_jday, ic%count_hour, ic%count_mins
				! it should be a counter base. ic%now%mins = 2 * ic%now%hour
				
				write(iun) ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count
				! write (*,*) 'ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count', & 
				! ic%ts_daily, ic%ts_hourly, ic%ts_halfhourly, ic%ts_count
				! ic%ts_daily : maybe reprent the increment length. ic%ts_count = ic%count_mins + 1
				

				!> Water balance totals.
				write(iun) TOTAL_PRE, TOTAL_EVAP, TOTAL_ROF, TOTAL_ROFO, TOTAL_ROFS, TOTAL_ROFB
				write(iun) STG_INI
				

				!> Daily streamflow values.
				write(iun) stfl%qhyd
				write(iun) stfl%qsyn

				!> Close the file to free the unit.
				close(iun)

			end if !(SAVERESUMEFLAG == 4) then
			
			!> Calculate final storage for the run.
			STG_FIN = sum(wb_grd%stg)/wb_grd%basin_area

			!> Basin totals for the run.
			TOTAL_PRE = TOTAL_PRE/wb_grd%basin_area
			TOTAL_EVAP = TOTAL_EVAP/wb_grd%basin_area
			TOTAL_ROF = TOTAL_ROF/wb_grd%basin_area
			TOTAL_ROFO = TOTAL_ROFO/wb_grd%basin_area
			TOTAL_ROFS = TOTAL_ROFS/wb_grd%basin_area
			TOTAL_ROFB = TOTAL_ROFB/wb_grd%basin_area

			!> Write basin totals to screen.
			if (ro%VERBOSEMODE > 0) then

				print *
				print 5641, 'Total Precipitation         (mm) =', TOTAL_PRE
				print 5641, 'Total Evaporation           (mm) =', TOTAL_EVAP
				print 5641, 'Total Runoff                (mm) =', TOTAL_ROF
				print 5641, 'Storage (Change/Init/Final) (mm) =', (STG_FIN - STG_INI), STG_INI, STG_FIN
				print *
				print 5641, 'Total Overland flow         (mm) =', TOTAL_ROFO
				print 5641, 'Total Interflow             (mm) =', TOTAL_ROFS
				print 5641, 'Total Baseflow              (mm) =', TOTAL_ROFB
				print *

5641    	format(3x, a34, 999(f11.3))
5635    	format(1x, 'Program has terminated normally.'/)

			end if !(ro%VERBOSEMODE > 0) then

			print 5635
					
			!--------------------------------------------------------------------------------
			!> Write data to the output summary file (MESH_output-echo_print).
			if (MODELINFOOUTFLAG > 0) then

				!> CLASS states for prognostic variables.
				NTYPE = shd%lc%NTYPE
				NSL = shd%lc%IGND
				
				! deallocate the CLASS states if they were allocated before 
				if (allocated (tcan))  deallocate (tcan)
				if (allocated (rcan))  deallocate (rcan)
				if (allocated (sncan)) deallocate (sncan)
				if (allocated (gro))   deallocate (gro)
				if (allocated (zpnd))  deallocate (zpnd)
				if (allocated (tpnd))  deallocate (tpnd)
				if (allocated (sno))   deallocate (sno)
				if (allocated (tsno))  deallocate (tsno)
				if (allocated (albs))  deallocate (albs)
				if (allocated (rhos))  deallocate (rhos)
				if (allocated (tbar))  deallocate (tbar)
				if (allocated (thlq))  deallocate (thlq)
				if (allocated (thic))  deallocate (thic)
				if (allocated (kc))    deallocate (kc)
                				
				
				
				allocate(tcan(3, NTYPE), rcan(3, NTYPE), sncan(3, NTYPE), gro(3, NTYPE), zpnd(3, NTYPE), tpnd(3, NTYPE), &
						 sno(3, NTYPE), tsno(3, NTYPE), albs(3, NTYPE), rhos(3, NTYPE), &
						 tbar(3, NTYPE, NSL), thlq(3, NTYPE, NSL), thic(3, NTYPE, NSL), kc(NTYPE))
				tcan = 0.0; rcan = 0.0; sncan = 0.0; gro = 0.0; zpnd = 0.0; tpnd = 0.0
				sno = 0.0; tsno = 0.0; albs = 0.0; rhos = 0.0
				tbar = 0.0; thlq = 0.0; thic = 0.0; kc = 0

				!> Loop through the GRUs.
				do m = 1, NTYPE

					!> Cycle if the GRU does not exist.
					if (count(shd%lc%JLMOS(1:NML) == m) == 0) cycle

					!> Canopy.
					tcan(3, m) = maxval(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m)
					if (tcan(3, m) > 0.0) then
						tcan(1, m) = sum(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m .and. &
										 stas%cnpy%tcan /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%cnpy%tcan /= 0.0)
						tcan(2, m) = minval(stas%cnpy%tcan, shd%lc%JLMOS(1:NML) == m .and. stas%cnpy%tcan /= 0.0)
					end if
					where (tcan < 173.16 .or. tcan > 373.16 .or. tcan == 0.0) tcan = 273.16
					rcan(2, m) = minval(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)
					rcan(3, m) = maxval(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)
					rcan(1, m) = sum(stas%cnpy%rcan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
					sncan(2, m) = minval(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)
					sncan(3, m) = maxval(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)
					sncan(1, m) = sum(stas%cnpy%sncan, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
					gro(2, m) = minval(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)
					gro(3, m) = maxval(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)
					gro(1, m) = sum(stas%cnpy%gro, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)

					!> Ponded water at surface.
					zpnd(2, m) = minval(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)
					zpnd(3, m) = maxval(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)
					zpnd(1, m) = sum(stas%sfc%zpnd, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
					tpnd(3, m) = maxval(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m)
					if (tpnd(3, m) > 0.0) then
						tpnd(1, m) = sum(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m .and. &
										 stas%sfc%tpnd /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sfc%tpnd /= 0.0)
						tpnd(2, m) = minval(stas%sfc%tpnd, shd%lc%JLMOS(1:NML) == m .and. stas%sfc%tpnd /= 0.0)
					end if
					where (tpnd < 173.16 .or. tpnd > 373.16 .or. tpnd == 0.0) tpnd = 273.16

					!> Snow.
					sno(2, m) = minval(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)
					sno(3, m) = maxval(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)
					sno(1, m) = sum(stas%sno%sno, shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
					tsno(3, m) = maxval(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m)
					if (tsno(3, m) > 0.0) then
						tsno(1, m) = sum(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m .and. &
										 stas%sno%tsno /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%tsno /= 0.0)
						tsno(2, m) = minval(stas%sno%tsno, shd%lc%JLMOS(1:NML) == m .and. stas%sno%tsno /= 0.0)
					end if
					where (tsno < 173.16 .or. tsno > 373.16 .or. tsno == 0.0) tsno = 273.16
					if (sno(3, m) > 0.0) then
						albs(1, m) = sum(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. &
										 stas%sno%sno > 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
						albs(2, m) = minval(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
						albs(3, m) = maxval(stas%sno%albs, shd%lc%JLMOS(1:NML) == m .and. stas%sno%sno > 0.0)
					end if
					rhos(3, m) = maxval(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m)
					if (rhos(3, m) > 0.0) then
						rhos(1, m) = sum(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m .and. &
										 stas%sno%rhos /= 0.0)/count(shd%lc%JLMOS(1:NML) == m .and. stas%sno%rhos /= 0.0)
						rhos(2, m) = minval(stas%sno%rhos, shd%lc%JLMOS(1:NML) == m .and. stas%sno%rhos /= 0.0)
					end if

					!> Soil.
					do j = 1, NSL
						tbar(1, m, j) = sum(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
						tbar(2, m, j) = minval(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
						tbar(3, m, j) = maxval(stas%sl%tbar(:, j), shd%lc%JLMOS(1:NML) == m)
						thlq(1, m, j) = sum(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
						thlq(2, m, j) = minval(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
						thlq(3, m, j) = maxval(stas%sl%thlq(:, j), shd%lc%JLMOS(1:NML) == m)
						thic(1, m, j) = sum(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)/count(shd%lc%JLMOS(1:NML) == m)
						thic(2, m, j) = minval(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)
						thic(3, m, j) = maxval(stas%sl%thic(:, j), shd%lc%JLMOS(1:NML) == m)
					end do
				end do

				!> Write to file.
				if (NRSOILAYEREADFLAG > 3) then
					ignd = min(NRSOILAYEREADFLAG, NSL)
				else if (NRSOILAYEREADFLAG == 1) then
					ignd = NSL
				else
					ignd = 3
				end if
				write(cfmt, '(i3)') ignd
				write(58, *)
				write(58, '(a)') 'End of run prognostic states'
				write(58, '(3x, (a), i4)') 'Number of GRUs: ', NTYPE
				do i = 1, 3
					write(58, *)
					select case (i)
						case (1); write(58, '(a)') 'Average values'
						case (2); write(58, '(a)') 'Minimum values'
						case (3); write(58, '(a)') 'Maximum values'
					end select
					do m = 1, NTYPE
						write(58, "(3x, 'GRU ', i3, ':')") m
						cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), 3(f10.3), " // &
								"2x, '!> TBAR(1:" // trim(adjustl(cfmt)) // ")/TCAN/TSNO/TPND')"
						write(58, cfmtt) ((tbar(i, m, j) - 273.16), j = 1, ignd), &
							(tcan(i, m) - 273.16), (tsno(i, m) - 273.16), (tpnd(i, m) - 273.16)
						cfmtt = "(" // trim(adjustl(cfmt)) // "(f10.3), " // trim(adjustl(cfmt)) // "(f10.3), f10.3, " // &
								"2x, '!> THLQ(1:" // trim(adjustl(cfmt)) // ")/THIC(1:" // trim(adjustl(cfmt)) // ")/ZPND')"
						write(58, cfmtt) (thlq(i, m, j), j = 1, ignd), (thic(i, m, j), j = 1, ignd), zpnd(i, m)
						write(58, "(6(f10.3), 2x, '!> RCAN/SNCAN/SNO/ALBS/RHOS/GRO')") &
							rcan(i, m), sncan(i, m), sno(i, m), albs(i, m), rhos(i, m), gro(i, m)
					end do
				end do

				!> Basin vertical water balance totals.
				write(58, *)
				write(58, '(a)') 'End of run totals'
				write(58, *)
				write(58, '(a, f11.3)') '  Total Precipitation         (mm) = ', TOTAL_PRE
				write(58, '(a, f11.3)') '  Total Evaporation           (mm) = ', TOTAL_EVAP
				write(58, '(a, f11.3)') '  Total Runoff                (mm) = ', TOTAL_ROF
				write(58, '(a, 3f11.3)') '  Storage(Change/Init/Final)  (mm) = ', (STG_FIN - STG_INI), STG_INI, STG_FIN
				write(58, '(a, f11.3)') '  Total Overland flow         (mm) = ', TOTAL_ROFO
				write(58, '(a, f11.3)') '  Total Interflow             (mm) = ', TOTAL_ROFS
				write(58, '(a, f11.3)') '  Total Baseflow              (mm) = ', TOTAL_ROFB
				write(58, *)

				!> Normal end of run message.
				write(58, *)
				write(58, '(a)') 'Program has terminated normally.'
				write(58, *)

				call cpu_time(endprog)
				write(58, "('Time = ', e14.6, ' seconds.')") (endprog - startprog)
			
			end if !(MODELINFOOUTFLAG > 0) then

		end if  !(ipid == 0 ) then
		
		
		
999     	continue
		
9002    	format(/1x, 'ERROR IN READING r2c_output.txt FILE.', &
				   /1x, 'THE FIRST RECORD AT THE FIRST LINE IS FOR THE NUMBER OF ALL THE', &
				   /1x, 'VARIABLES LISTED IN THE r2c_output.txt FILE.',&
				   /1x, 'THE SECOND RECORD AT THE FIRST LINE IS TIME STEP FOR R2C OUTPUT.', &
				   /1x, 'IT SHOULD BE AN INTEGER MULTIPLE OF 30.',&
				   /1x, 'THE REMAINING RECORDS SHOULD CONTAIN 3 COLUMNS FOR EACH VARIABLE WITH', &
				   /1x, 'INTEGER VALUES OF EITHER 0 OR 1,', &
				   /1x, 'AND 3 COLUMNS CONTAINING INFORMATION ABOUT THE VARIABLES.', /)
		
		!stop 
		
		!> Added by Ala Bahrami 
		! closing forcing files after one ensemble loop
		do i = 1 , 7
			close (cm%dat(i)%fiun)
		end do 
		
		! closing the forcepert input file 
		close(iun_per)	
		
		if ( tt .eq. N_ens) then 
					
					month_counter = month_counter + 1
					
					! Added by Ala Bahrami on 04/02/2019
					! writing the start time stamps  
					iun = 920
						open  (iun, file = 'Inputs/input_run_start.ini',status = 'replace', action = 'write')
						write (iun , *)'##### Simulation Run Times #####' 
						write (iun , *)'---#---#---#---#'
						write (iun , '(4i4)') ic%now%year, ic%now%jday, ic%now%hour, ic%now%mins
					
					close(iun)
					
					
					if (ic%now%year < ic%stop%year) then 
									goto 400 	
					else if(ic%now%year <= ic%stop%year)  then
							if (ic%now%jday < ic%stop%jday) then
									goto 400
							end if 									
					else  
								    exit	
					end if
					
					
		end if ! The last ensemble member 
	end do ! End of the ensemble loop 
		
	
	call mpi_finalize(ierr)
	
end 
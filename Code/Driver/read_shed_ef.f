C    This file is part of WATROUTE.
C
C    WATROUTE is free software: you can redistribute it and/or modify
C    it under the terms of the GNU Lesser General Public License as published by
C    the Free Software Foundation, either version 3 of the License, or
C    (at your option) any later version.
C
C    WATROUTE is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU Lesser General Public License for more details.
C
C    You should have received a copy of the GNU Lesser General Public License
C    along with WATROUTE.  If not, see <http://www.gnu.org/licenses/>.

!***********************************************************************
!       copyright (c) by Nick Kouwen and Dave Watson 2007
!***********************************************************************

      subroutine read_shed_ef(fls, indx, shd)

C***********************************************************************
C ****NOTE****This subroutine works but still requires extensive cleaning up
C **** Dave Watson is still working on it
C***********************************************************************!

c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C ~~~~NOTE:  This s/r was modified to read the gridded parameter file
C ~~~~as well as the shed file for watroute by NK  Jul. 5/07
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C***********************************************************************
C     written Mar/06 by Dave Watson
C     derived from rdshed written by Nick Kouwen
C     This subroutine reads the ensim compatible shd file (r2c format).
C This file is generated by a separate program called "BASIN" (by Nick Kouwen)
C***********************************************************************!
!
!  ntype    - max number of permeability classes in an element
!  al       - grid length in m.
!  step     - grid length in km but if al<1000, it is equal to 1
!  na       - total # of squares in the watershed including extra one in
!             which water runs. e.g.lake
!  xxx(n)    - the north-south coordinate of the n'th element
!  yyy(n)   - the east-west coordinate of the n'th element
!  order    - coordinate file,highest to lowest element.
!  da(n)    - drainage element (n).
!  ibn(n)   - basin number 1-5
!  irough(n)- over land flow conveyance class 1-5.
!  ichnl(n) - #channels/square class1-59
!  aimp(n)  - q/age impermeable area.from.01 to .9
!  next(n)  - the element number into which the n'th element drains
!  s(i,j)   - contains the order number for each square (used to be
!             drainage direction)
!           - impevious area should never be 1.0 or 0.0.

!***********************************************************************

      use sa_mesh_shared_variables
      use model_files_variables
      use strings

C//////////////////////////////////////////////
C/////////////////////////
C// Added by Dave

      use EF_Module

      implicit none

      type(ShedParam) :: header

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////

!     SAVES THE LOCAL VARIABLES FROM ONE RUN TO NEXT
!      save

!      character(128) qstr
!      character(20) junk, junk20
!      character(1) junk1
!      character(80) comment
!      character(79) hdrcomment(100)
!      integer chksum(160), thms(25), gr10k(25), saug(25), hmbr(25),
!     *  dffn(25), simpson(25), colum(50), canag(25), noire8k(25)
!      integer chsm, ndam1,
      integer
     *  iallcnt5, nrvr1,
!     *  dummy1, ntest, nchr, iallocate,
!     *  ios,
!     *  latdegmin, latminmin, latdegmax, latminmax, londegmin,
!     *  lonminmin, londegmax, lonminmax, i, j,
     *  n, ii
!     *  igridflg,
!     *  nrvr1, ntmp, l, newformat
      real sumclass
!     *  cintv, conv
!      integer(kind=2) result1, n_hdr_lines, zone
!      logical exists
      real, dimension(:, :), allocatable :: s

      type(fl_ids) :: fls
      integer, intent(in) :: indx
      type(ShedGridParams) :: shd

!      real(kind=4), dimension(:, :), allocatable :: dummy

!      DATA thms/0,211,176,148,108,70,42,14,11,0,0,0,0,0,0,0,0,0,0,0,0,
!     *          0,0,0,0/
!      data gr10k / 47, 161, 222, 229, 189, 142, 69, 39, 20, 7, 3, 0, 0,
!     *  0, 0, 0, 0, 0, 0, 0,
!     *  0, 0, 0, 0, 0 /
!      DATA canag/45,155,204,210,172,143,100,48,4,0,0,0,0,0,0,0,0,0,0,0,
!     *            0,0,0,0,0/
!      DATA saug/0,191,216,259,278,297,303,109,58,0,0,0,0,0,0,0,0,0,0,0,
!     *          0,0,0,0,0/
!      DATA hmbr/199,288,619,643,823,726,565,458,305,302,122,0,0,0,0,0,
!     *            0,0,0,0,0,0,0,0,0/
!      DATA dffn/149,498,623,610,431,396,223,73,0,0,0,0,0,0,0,0,0,0,0,0,
!     *            0,0,0,0,0/
!      DATA simpson/0,26,114,336,431,467,451,588,578,440,597,527,410,
!     *             292,203,0,0,0,0,0,0,0,0,0,0/
!      DATA colum/0,1100, 837, 723, 453, 711, 914,1072,1683,1621,1944,
!     *           2102,2528,2385,2175,1834,2049,2384,2611,2936,3165,2987,
!     *           2468,2709,2506,3315,3425,3132,2762,3366,
!     *           3059,2217,2021,1371,1336,1291, 904, 576,1118,1272, 359,
!     *              0,   0,   0,   0,   0,   0,   0,   0,   0/
!      data noire8k / 0, 0, 82, 179, 299, 213, 117, 288, 263, 222,
!     *  206, 169, 129, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /
!      data ntest / -10588 / qstr / 'copyright n.kouwen' / nchr / 18 /
!      data iallcnt5 / 0 /

C//////////////////////////////////////////////
C/////////////////////////
C// Added by Dave

C parameter type definitions
!      integer(kind=4) unitNum, flnNum, iStat
      integer ierr

C Local variables
      character(1024) line, subString, tmpString
      character(128) keyword
      integer lineLen, keyLen, wordCount, attCount
      logical rStat, lineType, foundEndHeader

      character(64) attribName
      integer ai, vi, xi, yi, attLen, error, rank
      real val

!Dan Princz changed this
CDAN      print*,'avant call initshedparam'
!      if (IOPT == 2) print *, 'avant call initshedparam'
C initialize default values
      call InitShedParam(header)

C Set unit and fln number
c unitNum = 31
c flnNum = 1

      foundEndHeader = .false.
      iallcnt5 = 1

!Dan Princz changed this
CDAN      print*,'in read_shed_ef with',unitNum,flnNum
!      if (IOPT == 2) print *, 'in read_shed_ef with', UNITNUM, FLNNUM

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////

!      if (.not. ID > 1) then      !  changed Jul. 12/04  nk
! else
!     TS: NNOTE=100 -> DEFINED AS A PARAMETER IN AREA10A
!     TS - ALLOCATION OF AREA10A ARRAY (REMAINDER)
!        if (iallcnt5 == 0) then
!          allocate(note(nnote), stat=iAllocate)
!          if (iAllocate /= 0) stop
!     *      'Error with allocation of area10a array in sheda'
!          iallcnt5 = 1
!        end if
!      end if

!     AL MUST BE IN INTEGER KILOMETERS
!     COORDINATES OF THE OUTSIDE ELEMENTS OF THE GRID.
!     ALL THE BASIN DATA IS READ ON FILE 9

!Dan Princz changed this
!      if (iopt == 2) print *, 'opening unitnum', unitnum
!      if (iopt == 2) print *, 'filename =', fln(flnnum)
CDAN      print*,'opening unitnum',unitnum
CDAN      print*,'filename =',fln(flnnum)

!     basin/bsnm_shd.r2c
      open(fls%fl(indx)%iun, file=adjustl(trim(fls%fl(indx)%fn)),
     +  status='old', iostat=ierr)
      if (ierr /= 0) then
        print *
        print *, 'Problems in file', adjustl(trim(fls%fl(indx)%fn))
!        write(*, 99162) fln(flnNum)
!        write(98, 99162) fln(flnNum)
!99162   format(' Warning: Error opening or reading fln:', a30/
!     *  ' Probable cause: missing basin/bsnm_???_par.r2c input file'/
!     *  ' OR: in config.sys have you set files=100 & buffers=50?'/
!     *  ' OR: wrong number in line 2 of the event file for '/
!     *  '     number of events listed in event file ')
        print *, 'iostat code =', ierr
        stop 'program aborted in read_shed_ef.for @ 130'
      end if

C//////////////////////////////////////////////
C/////////////////////////
C// Added by Dave
      line(1:1) = '#'

      do while ((.not. foundEndHeader) .and.
     &          ((line(1:1) == '#') .or.
     &           (line(1:1) == ':') .or.
     &           (len_trim(line) == 0)))
        read(fls%fl(indx)%iun, fmt='((A))', iostat=ierr) line ! read a line
        if (ierr == -1) then
          write(6,'((A))') 'ERROR: Premature EndOfFile encountered'
          stop ' Stopped in read_shed_ef'
        end if

c      print*,line
c      pause

        rStat = Detab(line)    ! replace tabs with spaces
        line = adjustl(line)  ! Get rid of leading white space
        lineLen = len_trim(line)  ! Find the length excluding trailing spaces

        if (line(1:1) == ':') then
          wordCount = SplitLine(line, keyword, subString) ! find the keyword
          rStat = ToLowerCase(keyword)
          KeyLen = len_trim(keyword)
          if (keyword(1:KeyLen) == ':endheader') then
            foundEndHeader = .true.
          else
            ierr = ParseShedParam(header, keyword, keyLen, subString)
            if (ierr < 0) then
              write(*, '(2(A))') 'ERROR parsing ',
     *          adjustl(trim(fls%fl(indx)%fn))
              write(*, '(2(A))') '   in line: ', line
              stop ' Stopped in read_shed_ef'
              return
            else if (ierr == 0) then
C     write(*,'((A), (A))')  'Unrecognized keyword line: ',
C     &          line
            end if
          end if
        end if
      end do

      shd%CoordSys%Proj = header%r2cp%csp%projection
      shd%CoordSys%Ellips = header%r2cp%csp%ellipsoid

      call writenum(header%r2cp%csp%zone, shd%CoordSys%Zone, 'i10')

      shd%xCount = header%r2cp%xCount
      shd%yCount = header%r2cp%yCount
      shd%xOrigin = header%r2cp%xOrigin
      shd%yOrigin = header%r2cp%yOrigin
      shd%xDelta = header%r2cp%xDelta
      shd%yDelta = header%r2cp%yDelta

      shd%AL = header%nominalGridSize_AL
!+      cintv = header%contourInterval

      shd%lc%NTYPE = header%classCount - 1
!        every where loops are ntype+1
!        this needs to be changed  fix fix
! ntype = header%classCount
!        to reading in the actual # land classes &
!         not no classes -1 for inpervious

      shd%NRVR = header%numRiverClasses

!+      conv = header%r2cp%unitConv

      shd%NA = header%totalNumOfGrids
      shd%NAA = header%numGridsInBasin
!+      nnprint = header%debugGridNo

c      if(iopt.eq.2)then
c        print*,'al,cintv,ntype,nrvr,conv',al,cintv,ntype,nrvr,conv
c        print*,'na,naa,nnprint',na,naa,nnprint
c        print*
c      endif

!      astep = al/1000.0
!      istep = int(astep)
!      step2 = astep*astep
!      if (istep < 1) istep = 1

c print*,'in read_shed_ef ',al,astep,istep,step2
c print*
c pause

      attCount = header%r2cp%ep%attCount
      call LoadAttributeData(header%r2cp%ep, shd%xCount, shd%yCount,
     +  fls%fl(indx)%iun)

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////

!       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!        imax = shd%yCount
!        jmax = shd%xCount

!       added ll separation Jul. 27/04  nk
C        if(coordsys1.eq.'LATLONG   ')then !commented out line below added by Dave
      if (IsLatLong(header%r2cp%csp)) then
        shd%iyMin = int(shd%yOrigin*60.0)
        shd%iyMax = int((shd%yOrigin + shd%yCount*shd%yDelta)*60.0)
        shd%jxMin = int(shd%xOrigin*60.0)
        shd%jxMax = int((shd%xOrigin + shd%xCount*shd%xDelta)*60.0)
!        llflg = 'y'          ! added Mar. 15/06 nk
        shd%GRDE = shd%xDelta*60.0
        shd%GRDN = shd%yDelta*60.0
      else
        shd%GRDE = shd%xDelta/1000.0
        shd%GRDN = shd%yDelta/1000.0
        shd%jxMin = int(shd%xOrigin/1000.0)
        shd%jxMax = shd%jxMin + shd%GRDE*(shd%xCount - 1)
        shd%iyMin = int(shd%yOrigin/1000.0)
        shd%iyMax = shd%iyMin + shd%GRDN*(shd%yCount - 1)
!        llflg = 'n'          ! added Mar. 15/06 nk
      end if

!Dan Princz changed this
CDAN      print*,'avant calling program flg,328'
!      if (IOPT == 2) print *, 'avant calling program flg, 328'
!      if (calling_program_flg == 'snw       ') return
!      if (calling_program_flg == 'moist     ') return

!      nastart = 1
!      naend = naa
!      imin = 1
!      jmin = 1
!      ib = imin + 1
!      it = imax - 1

!     rl() and ch_length() are the same thing. ch_length used in bsn

!     rev. 9.3.04  Oct.  24/06  - NK: routing parameters dim to na in rte

!     NOTE:  depending on whether this s/r is for rte or spl, dimension
!            routing pars differently.  na for rte & nrvr for spl
!            Now we dim all for na for spl & rte so mem is wasted in spl
!            But it is so read_shed_ef is the same for all.
!            Probably not a good idea to change for spl because of opt.

      if (iallcnt5 == 1) then

        allocate(s(shd%yCount, shd%xCount),
!     *    dummy(shd%yCount, shd%xCount),
     *    shd%xxx(shd%NA), shd%yyy(shd%NA),
!     *    flz2(na), pwr2(na),
!     *    sl2(na),
     *    shd%IROUGH(shd%NA),
     *    shd%lc%ACLASS(shd%NA, shd%lc%NTYPE + 1),
!     *    glacier_flag(na),
     *    stat=ierr)

        do ai = 1, attCount
          attribName = header%r2cp%ep%attList(ai)%name(:)
          rStat = ToLowerCase(attribName)
          attLen = len_trim(attribName)
          if (attribName(1:attLen) == 'next') then
            allocate(shd%NEXT(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'da') then
            allocate(shd%DA(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'bankfull') then
            allocate(shd%BNKFLL(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'chnlslope') then
            allocate(shd%SLOPE_CHNL(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'elev') then
            allocate(shd%ELEV(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'chnllength') then
            allocate(shd%CHNL_LEN(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'iak') then
            allocate(shd%IAK(shd%NA), stat=ierr)
!          else if (attribName(1:attLen) == 'intslope') then
!            allocate(sl1(na), stat=iAllocate)
          else if (attribName(1:attLen) == 'chnl') then
            allocate(shd%ICHNL(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'reach') then
            allocate(shd%IREACH(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'demslope') then
            allocate(shd%SLOPE_INT(shd%NA), stat=ierr)
          else if (attribName(1:attLen) == 'drdn') then
            allocate(shd%DRDN(shd%NA), stat=ierr)
!          else if (attribName(1:attLen) == 'flz') then
!            allocate(flz(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'pwr') then
!            allocate(pwr(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'r1n') then
!            allocate(r1n(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'r2n') then
!            allocate(r2n(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'mndr') then
!            allocate(mndr(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'aa2') then
!            allocate(aa2(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'aa3') then
!            allocate(aa3(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'aa4') then
!            allocate(aa4(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'theta')then
!            allocate(theta(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'widep') then
!            allocate(widep(na), stat=iAllocate)
!          else if (attribName(1:attLen) == 'kcond') then
!            allocate(kcond(na), stat=iAllocate)
          else if (attribName(1:attLen) == 'gridarea') then
            if (allocated (shd%AREA)) deallocate (shd%AREA)
            if (allocated (shd%FRAC)) deallocate (shd%FRAC)
			
			allocate(shd%AREA(shd%NA), stat=ierr)
            allocate(shd%FRAC(shd%NA), stat=ierr)
          end if
        end do
        if (ierr /= 0) stop
     *    'Error with allocation of area16a arrays in sheda'
!              glacier_flag(na)      added Mar, 28/06  nk
        iallcnt5 = 2
      end if

C//////////////////////////////////////////////
C/////////////////////////
C// Added by Dave

C// First find and copy rank attribute first data over to global array
!      if (unitnum == 31) then
!       for the shed file:
!        do ai = 1, attCount - (shd%lc%NTYPE + 1)
!          vi = 0
!          attribName = header%r2cp%ep%attList(ai)%name
!          rStat = ToLowerCase(attribName)
!          attLen = len_trim(attribName)
!          if (attribName(1:attLen) == 'rank') then
c reverse the direction of the yi loop
!            do yi = 1, yCount
C  do yi=yCount,1,-1
!              do xi = 1, xCount
!                vi = vi + 1
!                val = header%r2cp%ep%attList(ai)%val(vi)
!                s(yi, xi) = val
!              end do
!            end do
!          end if
!        end do
!      else
!       for the par file:
      do ai = 1, attCount
        vi = 0
        attribName = header%r2cp%ep%attList(ai)%name
        rStat = ToLowerCase(attribName)
        attLen = len_trim(attribName)
        if (attribName(1:attLen) == 'rank') then
          do yi = 1, shd%yCount
            do xi = 1, shd%xCount
              vi = vi + 1
              val = header%r2cp%ep%attList(ai)%val(vi)
              s(yi, xi) = val
            end do
          end do
        end if
      end do
!      end if

!C// Copy attribute data (not classes yet) over to global attributes
      vi = 0
!c reverse the direction of the yi loop
!c do yi=1,yCount
      do yi = 1, shd%yCount
        do xi = 1, shd%xCount
          vi = vi + 1
          rank = s(yi, xi)
          if (rank > 0) then
    !    do ai=1,attCount-ntype
    !c    do ai=1,attCount-(ntype+1)
            do ai = 1, attCount
              attribName = header%r2cp%ep%attList(ai)%name
              rStat = ToLowerCase(attribName)
              attLen = len_trim(attribName)
              val = header%r2cp%ep%attList(ai)%val(vi)
              if (attribName(1:attLen) == 'next') then
                shd%NEXT(rank) = int(val)
              else if (attribName(1:attLen) == 'da') then
                shd%DA(rank) = val
              else if (attribName(1:attLen) == 'bankfull') then
                shd%BNKFLL(rank) = val
              else if (attribName(1:attLen) == 'chnlslope') then
                shd%SLOPE_CHNL(rank) = val
              else if (attribName(1:attLen) == 'elev') then
                shd%ELEV(rank) = val
              else if (attribName(1:attLen) == 'chnllength') then
                shd%CHNL_LEN(rank) = val
              else if (attribName(1:attLen) == 'iak') then
                shd%IAK(rank) = int(val)
!              else if (attribName(1:attLen) == 'intslope') then
!                sl1(rank) = val
              else if (attribName(1:attLen) == 'chnl') then
                shd%ICHNL(rank) = int(val)
              else if (attribName(1:attLen) == 'reach') then
                shd%IREACH(rank) = int(val)
    ! Slope dem and drainage density  extracted from dem used in WARTROF.f G.sapriza 11/14
              else if (attribName(1:attLen) == 'demslope') then
                shd%SLOPE_INT(rank) = val
              else if (attribName(1:attLen) == 'drdn') then
!todo: At some point these units were keyed to the first grid square; whether or not it's -1.0 (or maybe 1.0)
                shd%DRDN(rank) = val
!                       Convert DD from km/km^2 to m/m^2
!                       The formulae in WATROF.f expect m/m^2
                shd%DRDN(rank) = shd%DRDN(rank)/1000.0

    !      WATROUTE attributes added by nk  Oct. 1/06
!              else if (attribName(1:attLen) == 'flz') then
!                flz(rank) = val
!              else if (attribName(1:attLen) == 'pwr') then
!                pwr(rank) = val
!              else if (attribName(1:attLen) == 'r1n') then
!                r1n(rank) = val
!              else if (attribName(1:attLen) == 'r2n') then
!                r2n(rank) = val
!              else if (attribName(1:attLen) == 'mndr') then
!                mndr(rank) = val
!              else if (attribName(1:attLen) == 'aa2') then
!                aa2(rank) = val
!              else if (attribName(1:attLen) == 'aa3') then
!                aa3(rank) = val
!              else if (attribName(1:attLen) == 'aa4') then
!                aa4(rank) = val
!              else if (attribName(1:attLen) == 'theta') then
!                theta(rank) = val
!              else if (attribName(1:attLen) == 'widep') then
!                widep(rank) = val
!              else if (attribName(1:attLen) == 'kcond') then
!                kcond(rank) = val
    !      end attributed added by nk

              else if (attribName(1:attLen) == 'gridarea') then
                shd%AREA(rank) = val
                shd%FRAC(rank)=shd%AREA(rank)/shd%AL/shd%AL
    !       frac is still used in the code but no longer in the shed file
!              else if (attribName(1:attLen) == 'frac') then
!    !    frac(rank) = val
!                print *
!                print *, 'Error: old format shd file found'
!                print *,
!     +            'Please create a new bsnm_shd.r2c file using the'
!                print *, 'current version of bsn.exe'
!                print *
!                stop 'Program aborted in read_shed_ef.for @ 447'
!      impervious area no longer used  nk
c          else if(attribName(1:attLen) .eq. 'imperv')then
c     aclass(rank, ntype+1) = val
!      end no longer used
              end if
            end do
          end if
        end do
      end do

!      manningflg = 'y'

C// Copy class attribute data over to global attributes
!      if (unitnum == 31) then
      vi = 0
c reverse the direction of the yi loop
      do yi = 1, shd%yCount
C   do yi=yCount,1,-1
        do xi = 1, shd%xCount
          vi = vi + 1
          rank = s(yi, xi)
          if (rank > 0) then
            do ai = attCount - shd%lc%NTYPE, attCount
              val = header%r2cp%ep%attList(ai)%val(vi)
              shd%lc%ACLASS(rank, ai - (attCount - (shd%lc%NTYPE + 1)))
     +          = val
!     aclass(rank,ai-(attCount-ntype)) = val
            end do
          end if
        end do
      end do
!      end if

!     pick the dominant class in this grid for debug printing
!      iiprint = 1
!      do ii = 2, ntype + 1
!        if (aclass(nnprint, ii) > aclass(nnprint, iiprint)) iiprint = ii
!      end do

C// Copy rows and col over to global attributes
C// I'm not sure if we need this...check with Nick
      vi = 0
      do yi = 1, shd%yCount
        do xi = 1, shd%xCount
          vi = vi + 1
          rank = s(yi, xi)
          if (rank > 0) then
            shd%xxx(rank) = xi
            shd%yyy(rank) = yi
          end if
        end do
      end do

!      do i = 1, ycount
!        do j = 1, xcount
!          dummy(i, j)=0.0
!        end do
!      end do

!     Write the land cover class fractions to spl.txt
!      if (iopt >= 1) then
!        write(51,50002)
!        do ii = 1, ntype + 1
!     write(51,50001)ii
!          do i = 1, ycount
!            do j = 1, xcount
!              n = s(i, j)
!              if (n > 0) dummy(i, j) = aclass(n, ii)
!            end do
!            write(51,50000)(dummy(i,j),j=1,xcount)
!          end do
!        end do
!      end if
!50000 format(999f6.2)
!50001 format('class no=', i5)
!50002 format('Land Cover class fractions:')

C// Deallocate the attribute data now that global attributes have been set
      do ai = 1, attCount
        deallocate(header%r2cp%ep%attList(ai)%val, STAT=error)
        if (error /= 0) stop 'deallocation error in read_gsm_ef()'
      end do

C Debug check for Dave
C do n=1,na
C  write(6,6004)n,next(n),yyy(n),xxx(n),da(n),bnkfll(n),
C     * slope(n),elev(n),rl(n), ibn(n),sl1(n),
C     * ichnl(n),ireach(n),frac(n),
C     * (aclass(n,ii),ii=1,ntype+1)
C       write(6,*)
C end do
C      pause 'in read_shed_ef  @  538'

C// End Dave addition
C/////////////////////////
C//////////////////////////////////////////////

!     GRAND RIVER:
!      if (iymin == 4790 .and. jxmin == 500) then
!        do i = 1, 25
!          chksum(i) = gr10k(i)
!        end do
!      end if

!      ichsm = 1
!     if one is no good, kill run
!      do i=1,min(25,imax)
!        chsm = 0
!        do j=jmin,jmax
!          chsm = chsm + s(i, j)
!        end do
!       print*,' i,shksun(i),chsm /',i,chksum(i),chsm
!        if (chsm /= chksum(i)) then
!          ichsm = 0        ! program will abort
!        end if
!      end do

! close this loophole - Oct. 15/03 NK
!     when the top left hand corner of the grid are all zeros
!     the checksums are all zero and the program would run.
!      chsm = 0
!      do i=1,min(25,imax)
!        do j=jmin,jmax
!          chsm = chsm + s(i, j)
!        end do
!      end do
!      if (chsm == 0) then
!        ichsm = 0        ! program will abort
!      end if

c!     South Nation
c      if(xcount.eq.75.and.ycount.eq.44.and.na.eq.1634.and.naa.eq.1631)
c     *then
c!   ichsm=1
c else
c!   ichsm=0        ! program will abort
c endif

!     rev. 9.1.46  Jul.  17/03  - WATFLOOD LITE incorporated
!     WATFLOOD LT
!     WATFLOOD LT
!      if(imax.le.7.and.jmax.le.7.and.na.le.15.and.al.le.2000.0)then
!       when ever these conditions are met, the program will run
!       Since the gr10k files exceed these bounds, the messages will
!       appropriate.
!        ichsm=3
!      end if
!     WATFLOOD LT
!     WATFLOOD LT

!todo: is using debug grid from shed file useful?
!      if (nnprint > naa) then
!        nnprint = naa/2
!        ipr = yyy(nnprint)   ! probably not needed anywhere
!        jpr = xxx(nnprint)
!      else
!       this can happen when a sub-watershed is used
!       for new format
!        ipr = yyy(nnprint)   ! probably not needed anywhere
!        jpr = xxx(nnprint)
!      end if
!      write(51,*)
!      write(51,5000)nnprint,ipr,jpr

!     REV. 8.92 - Dec.  24/89 -  CHECK FOR 100% ACLASS COVERAGE
!      igridflg = 0
      do n = 1, shd%NAA
        sumclass = 0.0
        do ii = 1, shd%lc%NTYPE + 1
          sumclass = sumclass + shd%lc%ACLASS(n, ii)
        end do
        if (sumclass /= 1.0) then
!          igridflg = 1
          if (ro%DIAGNOSEMODE > 0) then
            print 9023, n, shd%yyy(n), shd%xxx(n), sumclass
          end if
          do ii = 1, shd%lc%NTYPE + 1
            if (sumclass > 0.0) then
              shd%lc%ACLASS(n, ii) = shd%lc%ACLASS(n, ii)/sumclass
            else
              if (ro%DIAGNOSEMODE > 0) then
                print 9024, n, shd%yyy(n), shd%xxx(n)
              end if
            end if
          end do
        end if
      end do

!     FOR SPLD ONLY:
!     * * * * * * * * * * * * * * * * *
!     include 'demosize.for'

!     Checking data:

      nrvr1 = 0
      do n = 1, shd%NA
!       moved this to flowinit at one point but then it got
!       recalculated with each iteration when optimizing.
!       A serious snafu resulting in the convergence problem on opt.
        if (shd%SLOPE_CHNL(n) < 0.0) then
          print *, 'In read_shed_ef reading the file :',
     *      adjustl(trim(fls%fl(indx)%fn))
          print *, 'The slope in grid no ', n, ' is ', shd%SLOPE_CHNL(n)
          print *, 'Please check the elevations in the map file'
          print *, 'or change the slope value in the shd file'
          print *, 'The former is recommended as the permanent solution'
          print *
          stop 'Program aborted in read_shed_ef @ 756'
        end if
!CRAIG THOMPSON ADDED THIS
!        sl2(n) = sqrt(sl1(n))     ! used for overland flow routing (runof6)
!       check to see how many basins/river classes there are:
        nrvr1 = max(nrvr1, shd%IAK(n))
      end do

c      if( nrvr.ne.nrvr1)then
c!      if(nrvr.lt.nrvr1)then
c        print*,'no of river classes specifies in .shd header =',nrvr
c        print*,'no found in .shd grid data =',nrvr1
c        print*,'the header should = no found in gridded data'
c        print*,'the no in the header should be ',nrvr1
c        print*,'Ignore this warning if you are running a sub-watershed'
c        pause ' program paused in rd_shed_ef'
c      endif
c

      if (shd%NRVR /= nrvr1) then
        if (ro%VERBOSEMODE > 0) print 803, shd%NRVR, nrvr1
        shd%NRVR = nrvr1
      end if

803   format(
     *  /1x, 'WARNING: Total number of river classes is adjusted to',
     *  /1x, 'match IAK.',
     *  /3x, 'NRVR: ', i5,
     *  /3x, 'NRVR (adjusted): ', i5, /)

c      print*,'nrvr=',nrvr
c      print*
c      pause 'in read_shed_ef'
c
c
c      if(nrvr.le.0.or.nrvr.gt.16)then
c        print*,' In the .shd file: ',fln(flnNum)
c        print*,' Column 16-20 should have the value for nrvr'
c        print*,' the number of river classes '
c        print*,' It must have a value 1-16'
c        print*,' The number of river/basin types should match'
c        print*,' in the .par and .shd files'
c        print*,' Please enter the correct number in the'
c        print*,' .par and .shd files. To get the correct number,'
c        print*,' create a new .shd file using bsn.exe and then match'
c        print*,' it in the .par file - making sure there are an '
c        print*,' equal number of parameter sets for rivers'
c        print*
c        stop ' Program aborted in rdshd @ 729'
c      endif

c!     check ntypeo and nbsn:
c      if(ntypeo.gt.ntype)then
c        print*,' number of landcovers to be optimized greater than'
c        print*,' number of landcover classes in the .shd file'
c        print*
c        stop 'Program aborted in shed @ 236'
c      endif
c      if(nbsn.gt.nrvr)then
c        print*,' nbsn=',nbsn,' nrvr=',nrvr
c        print*,' number of river types to be optimized greater'
c        print*,' number of river classes found in the .shd file'
c        print*
c        stop 'Program aborted in shed @ 242'
c      endif

      close(fls%fl(indx)%iun)
!     WE WILL USE THIS UNIT NUMBER AGAIN FOR THE DAMAGE SITE FILE

!         write(51,6006)
!         write(51,6007)
!
!    write(51,*)' Note: order not the same as the .shd file YET'

c         if(ntype.le.0)then
c            do n=1,naa
c               write(51,6004)n,yyy(n),xxx(n),da(n),bnkfll(n),
c     *         slope(n)**2,
c     *         elev(n),ibn(n),sl2(n),ichnl(n),next(n),ireach(n),frac(n),
c     *        (aclass(n,ii),ii=1,ntype)
c            end do
c         else
c            do n=1,naa
c               write(51,6004)n,yyy(n),xxx(n),da(n),bnkfll(n),
c     *         slope(n)**2,elev(n),ibn(n),sl1(n),
c     *         ichnl(n),next(n),ireach(n),frac(n),aclass(n,ntype+1),
c     *         (aclass(n,ii),ii=1,ntype)
c            end do
c         endif
!      endif

c!     WRITE THE MAP INFORMATION TO THE /SPL/SIMOUT/PIC.LST FILE:
c      write(56,9005)na,jmax,imax
c      do n=1,na
c         write(56,9005)n,yyy(n),xxx(n),next(n)
c      end do

!     TS - ALLOCATIONS OF AREA4A ARRAYS
!     ntype for the number of land cover classes
!     nrivertype for the number of channel or basin types
!     moved here from spl9  nk 06/07/00
!     then moved from rdpar nk 28/12/04
!     parameter allocation moved to rdpar  27/07/06 nk  - needed by bsn
!     no good. Moved back here. fix bsn some other way

!     needed for rdpar

c      allocate(mndr(nrvr),
c     *r1(nrvr),r2(nrvr),r2low(nrvr),r2hgh(nrvr),r2dlt(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),thetadlt(nrvr),thetalow(nrvr),thetahgh(nrvr),
c     *widep(nrvr),widepdlt(nrvr),wideplow(nrvr),widephgh(nrvr),
c     *kcond(nrvr),kconddlt(nrvr),kcondlow(nrvr),kcondhgh(nrvr),
c     *flz(nrvr),flz2(nrvr),flzlow(nrvr),flzhgh(nrvr),flzdlt(nrvr),
c     *pwr(nrvr),pwr2(nrvr),pwrlow(nrvr),pwrhgh(nrvr),pwrdlt(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4a arrays in rdpar'

c      print*,'nrvr==',nrvr
c      print*,'nrvr==',nrvr,mndr(nrvr)
c      print*,'nrvr==',nrvr,mndr(nrvr),r1n(nrvr)
c      print*,'nrvr==',nrvr,mndr(nrvr),r1n(nrvr),r2n(nrvr)
c      print*
c      pause 'mmmmmmmmmmm'

c      allocate(
c     *mndr(nrvr),r1n(nrvr),r2n(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),widep(nrvr),kcond(nrvr),
c     *flz(nrvr),pwr(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4a arrays in read_shed_ef'

C     some of these are now allocated above for na instead of nrvr
c        for watroute because included in the shed file

c      allocate(mndr(nrvr),r1n(nrvr),r2n(nrvr),
c     *aa2(nrvr),aa3(nrvr),aa4(nrvr),rivtype(nrvr),
c     *theta(nrvr),widep(nrvr),kcond(nrvr),
c     *flz(nrvr),pwr(nrvr),
c     *stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4 arrays in read_shed_ef'

c!     these are not needed for watroute
c      if(.NOT.allocated(rivtype))then
c        allocate(rivtype(nrvr),stat=iAllocate)
c        if(iAllocate.ne.0) STOP
c     *   'Error with allocation of area4 arrays in read_shed_ef'
c      endif

! * * * *  TS  * * * * *
!     TS - ALLOCATIONS OF AREAWET ARRAYS
!      if (.not. allocated(wetwid)) then
!        allocate(wetwid(na), chawid(na), chadep(na), wstore1(na),
!     *    wstore2(na),
!     *    wcap(na), flowxa(na), chaxa(na), satxa(na), wetxa(na),
!     *    hcha1(na),
!     *    hcha2(na), hwet1(na), hwet2(na), qin(na), qswevp(na),
!     *    qswrain(na), qiwet1(na), qiwet2(na), qowet1(na), qowet2(na),
!     *    wetarea(na), chaarea(na), bin_precip(na), wsat(na),
!     *    wetfrac(na),
!     *    stat=iAllocate)
!        if (iAllocate /= 0) stop
!     *    'Warning: error with allocation of areaswmp in read_shed_ef'
!      end if
! * * * * * * * * * * *

!     TS - ALLOCATIONS OF AREA1A ARRAYS

!     *xxx(na),yyy(na),da(na),bnkfll(na),slope(na),elev(na),
!     *ibn(na),irough(na),ichnl(na),next(na),ireach(na),frac(na),
!     *aclass(na,ntype+1),ch_length(na),sl1(na),rl(na),
!     *pot(ntype+1),potfs(ntype+1),qlz(na),psmear(na),punused(na),
!      if (.not. allocated(qi1)) then
!        allocate(qi1(na), qi2(na), qo1(na), qo2(na), qr(na),
!     *    d2(na), qda(na), cap(na), over(na),
!     *    qmax(na), res(na),
!     *    sump(na), store1(na), store2(na), att(na),
!     *    qbase(na), nreach(30),
!     *    rf(na, ntype + 1), rffs(na, ntype + 1),
!     *    r(na, ntype + 1), effpor(na, ntype + 1),
!     *    v(na, ntype + 1), totd1(na), totuzs(na), totsnw(na),
!     *    qstream(na),
!     *    totchnl(na), totgrid(na), netflow(na), storinit(na),
!     *    d1(na, ntype + 1),
!     *    d1fs(na, ntype + 1), uzs(na, ntype + 1), uzsfs(na, ntype + 1),
!     *    lzs(na),
!     *    sumf(na, ntype + 1), sumrechrg(na),
!     *    sumffs(na, ntype + 1), snow(na, ntype + 1), sumrff(na),
!     *    rechrg(na),
!     *pot(ntype+1),potfs(ntype+1),    moved to rrpar  nk  May 15/07
!     *    qlz(na), sr(ntype + 1), x4(ntype + 1), x5(ntype + 1),
!     *    q1(na, ntype + 1),
!     *    q1fs(na, ntype + 1), qint(na, ntype + 1),
!     *    qintfs(na, ntype + 1),
!     *    fake(ntype + 1), fakefs(ntype + 1),
!     *    qdrng(na), qdrngfs(na),
!     *    drng(na, ntype + 1), drngfs(na, ntype + 1), sq1(ntype + 1),
!     *    sq1fs(ntype + 1), sqint(ntype + 1), sqintfs(ntype + 1),
!     *    sdrng(ntype + 1),
!     *    sdrngfs(ntype + 1), sexcess(ntype + 1), qstrm(na),
!     *    sumq1(na), sumqint(na), sumq1fs(na), sumqintfs(na),
!     *    stat=iAllocate)
!        if (iAllocate /= 0) stop
!     *    'Warning: error with allocation of area1 in read_shed_ef'
!      end if

!     TS - ALLOCATIONS OF AREAETA ARRAYS (PARTIAL)
!     RAD ALLOCATED IN SHEDA.FOR
!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
!      if (.not. allocated(strloss)) then
!        allocate(strloss(na), stat=iAllocate)
!        if (iAllocate /= 0) stop
!     *    'Warning: error with allocation of areaeta arrays in spl9'
!      end if

!     OCT30/03 TS:  ADDED SUMQI,SUMQINT,SUMQ1FS AND SUMQINTFS ALLOCATIONS

!     JUN28/06 TS: ADDED DF, DFFS FOR ISOTOPE ROUTINES
!      if (.not. allocated(df)) then
!        allocate(df(na, ntype + 1), dffs(na, ntype + 1),
!     *    qdrng2(na), qdrngfs2(na),
!     *    stat=iAllocate)
!        if (iAllocate /= 0) stop
!     *    'Warning: error with allocation of areaeta arrays in spl9'
!      end if

!     TS - ALLOCATIONS OF AREA4A ARRAYS
!     ntype for the number of land cover classes
!     nbsn for the number of channel or basin types
C      allocate(
C     *ds(ntype),dsfs(ntype),chnl(ntype),
C     *r3(ntype),r4(ntype),r3fs(ntype),rec(ntype),ak(ntype),akfs(ntype),
C     *r3low(ntype),r3fslow(ntype),reclow(ntype),
C     *aklow(ntype),akfslow(ntype),ak2fslow(ntype),
C     *r3hgh(ntype),r3fshgh(ntype),rechgh(ntype),akhgh(ntype),
C     *akfshgh(ntype),ak2fshgh(ntype),r3dlt(ntype),
C     *r3fsdlt(ntype),recdlt(ntype),akdlt(ntype),akfsdlt(ntype),
C     *ak2fsdlt(ntype),retn(ntype),ak2(ntype),
C     *retnlow(ntype),ak2low(ntype),
C     *retnhgh(ntype),ak2hgh(ntype),
C     *retndlt(ntype),ak2dlt(ntype),
C     *retfs(ntype),ak2fs(ntype),fpet(ntype),
C     *fpetdlt(ntype),fpetlow(ntype),fpethgh(ntype),ftall(ntype),
C     *ftalldlt(ntype),ftalllow(ntype),ftallhgh(ntype),nclass(ntype+1),
C     *iiclass(ntype*2),h(12,ntype),fpetmo(12,ntype),stat=iAllocate)
C      if(iAllocate.ne.0) STOP
C     *   'Warning: error with allocation of area4a arrays in spl9'

c!     TS - ALLOCATIONS OF AREAETA ARRAYS (PARTIAL)
c!     RAD ALLOCATED IN SHEDA.FOR
c!     rev. 9.1.80  Mar.  31/05  - NK: added sublimation   (sublim)
c      allocate(vo(na,ntype),intev(na,ntype+1),
c     *sublim(na,ntype+1),sum_sublim(na,ntype+1),
c     *sum_et(na,ntype+1),sum_pet(na,ntype+1),
c     *ev(na,ntype+1),pet(na,ntype+1),fpet2(na),
c     *x2(na,ntype),x3(na,ntype),intevt(na,ntype+1),
c     *evt(na,ntype+1),ssumr(na,ntype+1),totint(na),eloss(na),
c     *strloss(na),
c     *uzsinit(ntype+1),v1(na,ntype),radv(na),
c     *flgtemp(na),tto(na),ttomin(na),ttomax(na),ice_factor(na),
c     *evcg(na,ntype+1),acg(ntype+1),bcg(ntype+1),
c     *stat=iAllocate)
c !    *rh(na),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areaeta arrays in spl9'

! AB Added to make sure that intevt(n,ii)=intevt(n,ii)+intev(n,ii) in intcept works May 10, 2002
c do i=1,na
c   do j=1,ntype+1
c     intevt(i,j)=0
c   enddo
c enddo

!     TS - ALLOCATIONS OF AREAMELTA ARRAYS (PARTIAL)
!     SNW,DSN,TTEMP,TMX,TMN,EL ALLOCATED IN SHEDA.FOR
!     SDCD,SDCSCA ALLOCATED IN RDSDCA.FOR
c      allocate(snowc(na,ntype+1),dsnow(na),
c     *tmax(na),tmin(na),
c     *tmin1(na),tmin2(na),sca(na,ntype+1),oldsca(na,ntype+1),
c     *fexcess(na,ntype+1),snowcmin(na,ntype+1),wcl(na,ntype+1),
c     *nsdc(ntype+1),
c     *snocap(ntype+1),
c     *ati(na,ntype+1),def(na,ntype+1),
c     *qtot(ntype+1),robg(ntype+1),rosn(ntype+1),qnet(ntype+1),
c     *smelt(ntype+1),excess(ntype+1),extra(ntype+1),idump(ntype+1),
c     *qrain(ntype+1),qsnow(ntype+1),qrn(na),qsn(na),glmelt(na),
c     *qe(ntype+1),qh(ntype+1),qn(ntype+1),qp(ntype+1),refrz(ntype+1),
c     *fmadj(na),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areamelta arrays in spl9'

! AB Added to make sure that min(tempv(n),tempvmin(n)) in rdtemp works May 10, 2002
c      do n=1,na
c!   tempvmin(n)=99.99
c        do ii=1,ntype+1
c          wcl(n,ii)=0.0
c        end do
c enddo

c!     TS - ALLOCATIONS OF AREAOPTSA ARRAYS
c      allocate(fmdlt(ntype),fmlow(ntype),fmhgh(ntype),fmndlt(ntype),
c     *fmnlow(ntype),fmnhgh(ntype),uajdlt(ntype),uajlow(ntype),
c     *uajhgh(ntype),mbsdlt(ntype),mbslow(ntype),mbshgh(ntype),
c     *basdlt(ntype),baslow(ntype),bashgh(ntype),stat=iAllocate)
c      if(iAllocate.ne.0) STOP
c     *   'Warning: error with allocation of areaoptsa arrays in spl9'

c      if(newevtflg.eq.'y')then
c!       section added for new .pdl file   NK 04/10/04
c
c        INQUIRE(FILE=fln(3),EXIST=exists)
c        IF(exists)THEN
c
c          open(unit=33,file=fln(3),status='old',iostat=ios)
c     if(ios.ne.0)then
c       print*,'Problems opening .pdl file ',fln(3)
c       print*
c            stop 'Program aborted in shed @ 903'
c     endif
c          junk='                    '
c     do while(junk.ne.':NoDamageSites      ')
c            read(33,*,iostat=ios)junk
c            if(ios.ne.0)then
c              print*,'last line read in the .pdl file ='
c              print*,junk
c              print*,' \ios =',ios
c              ndam=0
c              return        ! >>>>>>>>>>>>>>>>>>>>>>>>
c            endif
c          end do
c          backspace(33)
c          read(33,*)junk,ndam
c
c          if(ndam.eq.0)return     ! >>>>>>>>>>>>>>>>>>
c
c          read(33,*)junk       !    #
c!         NOW WE GET TO THE DAMAGE LOCATIONS:
c!         IN OLD FILES, NO DAMAGE LOCATIONS WERE SPECIFIED
c!         SO THE NO. OF DAMAGE SITES IS SET TO 0 - NO PROBLEM
c
c          if(.not.id.gt.1)THEN
c            ndam1=max(1,ndam)
c!           can not allocate 0,nnnn - I guess NK  16/08/00
c!           TS - ALLOCATION OF AREA10A ARRAYS (REMAINDER)
c            if(iallcnt5.eq.2)then
c!               these will replace iys & jxs respectively
c             allocate(xdamg_locn(ndam1),ydamg_locn(ndam1),
c     *         iys(ndam1),jxs(ndam1),datum(ndam1),frcs(ndam1,41),
c     *         damage(ndam1),qloc(ndam1,8784),stat=iAllocate)
c             if(iAllocate.ne.0) STOP
c     *         'Error with allocation of area10a arrays in sheda'
c             iallcnt5=3
c       endif
c     ENDIF
c
c          do l=1,ndam
c            read(33,*,iostat=ios)xdamg_locn(l),ydamg_locn(l),
c     *                      damage(l),(frcs(l,i),i=1,4),datum(l)
c            if(ios.ne.0)then
c              print*,'problems reading damage location =',ndam
c            endif
c
c!         need fix fix for ll also
c            jxs(l)=int(xdamg_locn(l)/1000.)
c            iys(l)=int(ydamg_locn(l)/1000.)
c
c            iys(l)=(iys(l)-iymin)/istep+1
c            jxs(l)=(jxs(l)-jxmin)/istep+1
c
c!           DAMAGE LOCATIONS ARE NOW CONVERTED TO COMPUTATION
c!           GRID COORDINATES
c            write(55,1102)iys(l),jxs(l),damage(l),(frcs(l,i),i=1,4),
c     *                 datum(l)
c          end do
c
c          read(33,*)junk       !    #
c
c          do i=1,nnote
c            read(33,1098,end=480)note(i)
c!           write(*,1098)note(i)
c          end do
c  480     CONTINUE
c!         redefine the size of the array for later printing:
c          nnnote=i-1
c          write(55,1098)(note(i),i=1,nnnote)
c          close(unit=33)
c        endif      ! if fln(3) exists
c!       fix fix section above for new coordinate formats utm & ll
c
c else
c!       old format file
c!       READ THE DAMAGE SITE LOCATIONS FROM THE BASIN/XXXX.STR FILE:
c
c        INQUIRE(FILE=fln(4),EXIST=exists)
c        IF(exists)THEN
c
c          open(unit=34,file=fln(4),status='old',err=99901)
c          if(ios.ne.0)then
c      print*,'Problems reading basin\bsnm.str file'
c      print*,'Expected file name =',fln(4)
c      print*
c           stop 'Program terminated in read_shed_ef @ 899'
c    endif
c
c         read (34,1000,err=99910)ntmp
c         do n=1,ntmp
c            read (34,*,err=99910)
c         end do
c
c         THIS FILE ALSO HAS THE RESERVOIR LOCATION COORDINATES
c         read (34,6014,end=9998)ntmp
c
c         if(ntmp.gt.0)then
c           do n=1,ntmp
c              read (34,*,end=9998)
c           end do
c         endif
c
c         THIS FILE ALSO HAS THE RESERVOIR LOCATION COORDINATES
c
c         NOW WE GET TO THE DAMAGE LOCATIONS:
c         IN OLD FILES, NO DAMAGE LOCATIONS WERE SPECIFIED
c         SO THE NO. OF DAMAGE SITES IS SET TO 0 - NO PROBLEM
c
c         read(34,1000,end=9999)ndam
c
c
c         if(id.gt.1)THEN
c           dummy
c    ELSE
c           ndam1=max(1,ndam)
c           can not allocate 0,nnnn - I guess NK  16/08/00
c           TS - ALLOCATION OF AREA10A ARRAYS (REMAINDER)
c           if(iallcnt5.eq.2)then
c            allocate(iys(ndam1),jxs(ndam1),datum(ndam1),frcs(ndam1,41),
c    *         damage(ndam1),qloc(ndam1,8784),stat=iAllocate)
c            if(iAllocate.ne.0) STOP
c    *         'Error with allocation of area10a arrays in sheda'
c            iallcnt5=3
c      endif
c    ENDIF
c
c         do l=1,ndam
c           read(34,1099,end=9999)iys(l),jxs(l),damage(l),
c    *                           (frcs(l,i),i=1,4),datum(l)
c
c           iys(l)=(iys(l)-iymin)/istep+1
c           jxs(l)=(jxs(l)-jxmin)/istep+1
c
c           DAMAGE LOCATIONS ARE NOW CONVERTED TO COMPUTATION
c           GRID COORDINATES
c           write(55,1102)iys(l),jxs(l),damage(l),(frcs(l,i),i=1,4),
c    *                 datum(l)
c         end do
c
c         do i=1,nnote
c           read(34,1098,end=490)note(i)
c           write(*,1098)note(i)
c         end do
c 490     CONTINUE
c         redefine the size of the array for later printing:
c         nnnote=i-1
c         write(55,1098)(note(i),i=1,nnnote)
c         close(unit=34)
c       endif    !  if fln(4) exists
c     endif

      return

! 9998 ntmp = 0
!      ndam = 0
!      write(98, 9025)
!      write(98, 9026)
!      close(34)
!      return

! 9999 ndam = 0
!      write(98, 9026)
!      close(34)
!      return

!99901 write(*, 99902) fln(4)
!99902 format(' file', a30, ' not found for unit 34 - check event file')
!      stop 'program stopped in shed.for at 99902'

!99910 write(*, 99911) fln(4)
!99911 format(' no data found or problems with data in ', a30)
!      stop 'program stopped in shed at 99911'

! FORMATS

!1000  format(i5)
!1002  format(' ', i5, 'stream gage locations have been passed over')
!1003  format(' ', i5, 'reservoir locations have been passed over')
!1004  format(' ', i5, 'damage sites:')
!1098  format(a80)
!1099  format(2i5, 1x, a12, 7x, 4e10.3, f10.3)
!1100  format(' ', 2i5, 1x, a12, 7x, 4e10.3, f10.3)
!1101  format(' reading the stream gauge location file: ', a30)
!1102  format(' ', 2i5, 1x, a12, 7x, 4e10.3, f10.3/)
!1776  format(' ', 'l,iys(l),jxs(l)', 5i5)
!        write(51,*)

!5000  format(' Debug grid reset to grid number n,row col', 3i7)

!6004  format(1x, 4i4, f7.1, f7.2, f8.4, 2f7.0, i3, f7.4, 2i3, 7f5.2)
!6006  format(2x, 'basin file:')
!6007  format(4x, 'n   yy   xx      da       cap       slope    elv',
!     *'     ibn   sl2    ich  next reach frac  imp area & fractions')
!6014  format(i5)

!9005  format(12i5, 2f5.0)

9023  format(
     *  1x, 'WARNING: Area correction in grid n(i, j): ', 3i5, f9.5)
9024  format(1x, 'WARNING: Total area = 0.0 in grid n (i, j): ', 3i5)
!9025  format(' Warning: no reservoirs or lakes in bsnm.str file')
!9026  format(' Warning: no damage sites in bsnm.str file')

      return

      end subroutine
